# 3. 页表

页表是操作系统为每个进程提供其私有地址空间和内存的最流行机制。页表决定了内存地址的含义以及可以访问的物理内存的部分。它们允许 xv6 将不同进程的地址空间隔离，并将它们复用到单个物理内存上。页表之所以受欢迎，是因为它们提供了一种间接性，允许操作系统执行许多技巧。Xv6 执行了一些技巧：在多个地址空间中映射相同的内存（跳板页面）以及用未映射的页面保护内核和用户栈。本章剩余部分将解释 RISC-V 硬件提供的页表以及 xv6 如何使用它们。

## 分页硬件

作为提醒，RISC-V指令（用户和内核）操作虚拟地址。机器的 RAM 或物理内存，使用物理地址进行索引。RISC-V 页表硬件将这两种地址连接起来，将每个虚拟地址映射到一个物理地址。

Xv6 运行在 Sv39 RISC-V 上，这意味着 64 位虚拟地址的底部 39 位被使用；顶部 25 位未使用。在此 Sv39 配置中，RISC-V 页表从逻辑上看是一个包含 $2^{27}$（134,217,728）个页表条目（`Page Table Entries` / PTEs）的数组。每个 PTE 包含一个 44 位的物理页号（ `Physical Page Number` / PPN ）和一些标志。分页硬件通过使用 39 位中的顶部 27 位来索引页表以找到 PTE，并生成一个 56 位的物理地址，其顶部 44 位来自 PTE 中的 PPN，底部 12 位从原始虚拟地址复制。图3.1展示了这个过程，将页表作为一个简单的 PTE 数组（参见图3.2，了解更多信息）。页表以 4096（$2^{12}$）字节对齐的块为粒度，为操作系统提供对虚拟地址到物理地址转换的控制。这样的块被称为**页**。

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p1.png)

在 Sv39 RISC-V 中，虚拟地址的前 25 位未用于翻译。物理地址也有增长的空间：PTE格式中有 10 位的物理页号增长空间。RISC-V 的设计者根据技术预测选择了这些数字。$2^{39}$ 字节是 512 GB，应该足够应用程序在 RISC-V 计算机上运行的地址空间。$2^{56}$ 足以容纳许多 I/O 设备和 DRAM 芯片的物理内存空间用于满足不久的将来的许多 I/O 设备和 DRAM 芯片的需求。如果需要更多，RISC-V 设计者已经定义了具有 48 位虚拟地址的 Sv48 。

如图 3.2 所示，RISC-V CPU 将虚拟地址转换为物理地址分为三个步骤。页表存储在物理内存中，作为一个三级树。树的根是一个包含 512 个 PTE 的 4096 字节页表页，这些PTE 包含树的下一级的页表页的物理地址。这些页面中的每一个都包含 512 个用于树最后一级的 PTE 。分页硬件使用 27 位中的顶部 9 位来选择根页表页中的 PTE，中间 9 位来选择下一级的页表页中的 PTE，底部 9 位来选择最终的 PTE。（在 Sv48 RISC-V 中，页表有四个层次，虚拟地址的 39 至 47 位索引到顶层。）

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p2.png)

如果转换地址所需的任何三个PTE都不存在，分页硬件会引发一个页面错误异常，将处理异常的任务留给内核（参见第 4 章）。

图3.2中的三级结构允许记录 PTE 的内存高效方式，与图中的单级设计相比。在虚拟地址的大部分范围没有映射的常见情况下，三级结构可以省略整个页目录。例如，如果一个应用程序仅使用从地址零开始的几个页面，那么顶级页目录中的 1 至 511 项都是无效的，内核不必为这 511 个中间页目录分配页面。此外，内核还不必为这 511 个中间页目录的底层页目录分配页面。因此，在这个例子中，三级设计为中间页目录节省了 511 个页面，为底层页目录节省了 $511 \times512$ 个页面。

尽管 CPU 在执行加载或存储指令的过程中以硬件方式遍历三级结构，但三级结构的潜在缺点是 CPU 必须从内存加载三个 PTE 来执行加载/存储指令中的虚拟地址到物理地址的转换。为了避免从物理内存加载 PTE 的开销，RISC-V CPU 将页表条目缓存在转换缓冲区（`Translation Look-aside Buffer`, TLB）中。

每个 PTE 包含一些标志位，告诉分页硬件如何使用相关的虚拟地址。

- `PTE_V` 表示PTE是否存在：如果未设置，则对页面的引用会引发异常（即，不允许）。
- `PTE_R` 控制是否允许指令读取页面。
- `PTE_W` 控制是否允许指令写入页面。
- `PTE_X` 控制CPU是否可以将页面内容解释为指令并执行它们。
- `PTE_U` 控制用户模式下的指令是否允许访问页面；如果 PTE_U 未设置，则PTE 只能在监视器模式下使用。

图 3.2 展示了这个过程如何工作。标志位和所有其他与页面硬件相关的结构在 `kernel/riscv.h` 中定义。

要让 CPU 使用页表，内核必须将根页表页的物理地址写入 `satp` 寄存器。CPU 将使用 `satp` 指向的页表转换后续指令生成的所有地址。每个 CPU 都有自己的 `satp`，以便不同的 CPU 可以运行具有由自己的页表描述的私有地址空间的不同进程。

通常，内核将所有物理内存映射到其页表中，以便它可以使用加载/存储指令读取和写入物理内存中的任何位置。由于页目录位于物理内存中，内核可以通过使用标准 `store ` 指令将 PTE 的内容写入页目录中的 PTE 的虚拟地址来编程 PTE。

关于术语的一些说明。物理内存是指 DRAM 中的存储单元。物理内存的一个字节具有一个地址，称为物理地址。指令仅使用虚拟地址，分页硬件将其转换为物理地址，然后将其发送到 DRAM 硬件以读取或写入存储。与物理内存和虚拟地址不同，虚拟内存不是物理对象，而是指内核用于管理物理内存和虚拟地址的一组抽象和机制。

## 内核地址空间

Xv6 为每个进程维护一个页表，描述每个进程的用户地址空间，以及描述内核地址空间的单个页表。内核配置其地址空间的布局，使自己能够以可预测的虚拟地址访问物理内存和各种硬件资源。图 3.3 展示了这种布局如何将内核虚拟地址映射到物理地址。文件 `kernel/memlayout.h` 声明了 xv6 内核内存布局的常量。

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p3.png)

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p4.png)

图中左侧为 xv6 的内核地址空间。`RWX` 表示 PTE 的读、写和执行权限。右侧为 xv6 期望看到的 RISC-V 物理地址空间。



QEMU 模拟了一个包含RAM（物理内存）的计算机，从物理地址 $0x80000000$ 开始，至少持续到 $0x88000000$，xv6 称之为 `PHYSTOP`。QEMU 模拟还包括 I/O 设备，如磁盘接口。QEMU 将设备接口以内存映射控制寄存器的形式暴露给软件，位于物理地址空间 $0x80000000$ 以下。内核可以通过读/写这些特殊物理地址与设备交互；这种读写是与设备硬件通信，而不是与 RAM 通信。第 4 章解释了 xv6 如何与设备交互。

内核通过“直接映射”来访问RAM和内存映射的设备寄存器；也就是说，将这些资源映射到等于物理地址的虚拟地址。例如，内核本身位于虚拟地址空间和物理内存中的 $KERNBASE=0x80000000$ 。直接映射简化了读取或写入物理内存的内核代码。例如，当 `fork` 为子进程分配用户内存时，分配器返回该内存的物理地址；`fork` 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。

有几个内核虚拟地址没有直接映射：

*   跳板页。它映射在虚拟地址空间的顶部；用户页表具有相同的映射。第 4 章讨论了跳板页的作用，但我们在这里看到一个有趣的页表用例；一个物理页（包含跳板代码）在内核的虚拟地址空间中被映射了两次：一次在虚拟地址空间的顶部，一次在直接映射中。

*   内核栈页。每个进程都有自己的内核栈，映射在高地址，这样 xv6 可以在它下面留一个未映射的保护页。保护页的PTE是无效的（即，`PTE_V` 未设置），这样如果内核溢出一个内核栈，它可能会引发异常，内核将出现恐慌。没有保护页，溢出的栈将覆盖其他内核内存，导致操作不正确。恐慌崩溃更可取。

尽管内核通过高内存映射使用其栈，它们也可以通过直接映射的地址访问。另一种设计可能只有直接映射，并在直接映射地址处使用栈。然而，在这种安排中，提供保护页将涉及取消映射虚拟地址，否则将引用物理内存，这将很难使用。

内核使用 `PTE_R` 和 `PTE_X` 权限映射跳板页和内核文本的页。内核从这些页面读取并执行指令。内核使用 `PTE_R` 和 `PTE_W` 权限映射其他页面，以便它可以读取和写入这些页面中的内存。保护页的映射是无效的。



## 代码：创建地址空间

大部分处理地址空间和页表的 xv6 代码位于 `vm.c`  (ker- nel/vm.c:1) 文件中。核心数据结构是 `pagetable_t`，它实际上是一个指向 RISC-V 根页表页的指针；`pagetable_t` 可以是内核页表，也可以是每个进程的页表之一。核心函数有 `walk`，用于查找虚拟地址的PTE，以及 `mappages`，用于为新映射安装 PTE。以 `kvm` 开头的函数操作内核页表；以 `uvm` 开头的函数操作用户页表；其他函数都用于两者。`copyout` 和 `copyin` 将数据从系统调用参数提供的用户虚拟地址复制出和复制入；它们位于 `vm.c` 中，因为它们需要显式转换这些地址以找到相应的物理内存。

在启动序列的早期，`main` 函数调用 `kvminit` 函数（位于 `kernel/vm.c` 文件中）来使用 `kvmmake` 函数创建内核的页表。在启用 RISC-V 上的分页之前进行此调用，因此地址直接引用物理内存。`kvmmake` 首先分配一个物理内存页来保存根页表页。然后它调用 `kvmmap` 以安装内核所需的转换。转换包括内核的指令和数据、物理内存（直到 `PHYSTOP`）以及实际上是设备的内存范围。`proc_mapstacks` 为每个进程分配一个内核栈。它调用 `kvmmap` 在由 `KSTACK` 生成的虚拟地址处映射每个栈，从而为无效的栈保护页留出空间。

`kvmmap` 函数（位于 `kernel/vm.c` 文件中）调用 `mappages` 函数，为虚拟地址范围到相应物理地址范围的映射安装映射到页表中。它分别针对范围内的每个虚拟地址执行此操作，按页间隔。对于要映射的每个虚拟地址，`mappages` 调用 `walk` 函数以查找该地址的 PTE 地址。然后，它将 PTE 初始化为包含相关物理页号、所需权限（`PTE_W`，`PTE_X` 和/或 `PTE_R`）以及 `PTE_V`，以将 PTE 标记为有效。

`walk` 函数（位于 `kernel/vm.c` 文件中）在查找虚拟地址的 PTE 时模拟 RISC-V 分页硬件（参见图3.2 ）。`walk` 按每次 9 位逐层降低 3 级页表。它使用每一层的 9 位虚拟地址来查找下一级页表的 PTE 或最终页面。如果 PTE 无效，那么尚未分配所需的页面；如果 `alloc` 参数被设置，`walk` 分配一个新的页表页并将其物理地址放入 PTE 中。它返回树中最低层的 PTE 地址。

上述代码依赖于物理内存直接映射到内核虚拟地址空间。例如，在 `walk` 函数中，当它逐层降低页表时，它从 PTE 中提取下一级页表的（物理）地址，然后将该地址用作虚拟地址，以获取下一级的 PTE。

main 函数调用 kvminithart 函数（位于 kernel/vm.c: 62 文件中）安装内核页表。它将根页表页的物理地址写入寄存器 satp。此后，CPU 将使用内核页表转换地址。由于内核使用身份映射，现在虚拟地址的下一条指令将映射到正确的物理内存地址。

每个 RISC-V CPU 在 `Translation Look-aside Buffer (TLB)` 中缓存页表条目，当 xv6 更改页表时，必须告诉 CPU 使相应的缓存 TLB 条目无效。如果不这样做，那么稍后 TLB 可能会使用旧的缓存映射，指向在此期间已分配给另一个进程的物理页，因此，进程可能会在其他进程的内存上涂鸦。RISC-V 有一个指令 `sfence.vma`，用于刷新当前 CPU 的 TLB。在重新加载 satp 寄存器之后，xv6 在 `kvminithart` 函数中执行 sfence.vma，并在在返回用户空间之前切换到用户页表的 `trampoline` (kernel/trampoline.S:89) 代码中执行。

在更改 satp 之前也有必要发出 sfence.vma，以等待所有未完成的加载和存储操作。这个等待确保先前对页表的更新已经完成，确保先前的加载和存储使用旧的页表，而不是新的页表。

为了避免刷新完整的 TLB，RISC-V CPU 可能支持地址空间标识符（ASIDs）。内核可以刷新特定地址空间的 TLB 条目。xv6 没有使用这个功能。

## 物理内存分配

内核必须在运行时为页表、用户内存、内核栈和管道缓冲区分配和释放物理内存。

xv6 使用内核结束和 PHYSTOP 之间的物理内存进行运行时分配。它一次分配和释放整个 4096 字节的页面。它通过在页面本身中线程链接列表来跟踪哪些页面是空闲的。分配包括从链表中删除一个页面；释放包括将释放的页面添加到列表中。

## 代码：物理内存分配器

分配器位于 `kalloc.c`  (kernel/kalloc.c:1) 文件中。分配器的数据结构是一个物理内存页面的 ${free\ list}$，这些页面可用于分配。每个空闲页面的列表元素都是一个 `struct run` (kernel/kalloc.c:17)。分配器从哪里获得用于保存该数据结构的内存呢？它将每个空闲页面的 `run` 结构存储在空闲页面本身中，因为那里没有其他存储内容。空闲列表受到自旋锁 (kernel/kalloc.c:21-24) 的保护。列表和锁包装在一个结构体中，以明确锁保护结构体中的字段。现在，忽略锁和对 `acquire` 和 `release` 的调用；第 6 章将详细研究锁定。

`main` 函数调用 `kinit` 函数初始化分配器 (kernel/kalloc.c:27). 。`kinit` 初始化空闲列表，以包含内核结束和 PHYSTOP 之间的每个页面。xv6 应该通过解析硬件提供的配置信息来确定可用的物理内存数量。然而，xv6 假设机器拥有 128 兆字节的 RAM。kinit 调用 freerange 函数通过每个页面调用 kfree 向空闲列表添加内存。一个 PTE 只能引用对齐在 4096 字节边界（是 4096 的倍数）的物理地址，因此 freerange 使用 PGROUNDUP 确保它只释放对齐的物理地址。分配器从没有内存开始；这些对 kfree 的调用为其提供了一些要管理的内存。

分配器有时将地址视为整数以便对它们执行算术运算（例如，遍历 freerange 中的所有页面），有时将地址用作指针以读取和写入内存（例如，操作存储在每个页面中的 run 结构）；这种对地址的双重使用是分配器代码充满 C 类型转换的主要原因。类型转换的另一个原因是释放和分配本质上改变了内存的类型。

kfree (kernel/kalloc.c:47) 函数从将要释放的内存中的每个字节设置为值 1 开始。这将导致在释放内存后使用内存的代码（使用“悬空引用”）读取垃圾而不是旧的有效内容；希望这会使这样的代码更快地崩溃。然后 kfree 将页面添加到空闲列表的开头：它将 pa 转换为指向 struct run 的指针，将空闲列表的旧起点记录在 r->next 中，并将空闲列表设置为 r。kalloc 函数删除并返回空闲列表中的第一个元素。



## 进程地址空间

每个进程都有一个单独的页表，当 xv6 在进程之间切换时，它还会更改页表。图3.4更详细地显示了一个进程的地址空间，比图 2.3 更详细。进程的用户内存从虚拟地址零开始，可以增长到 `MAXVA` (`kernel/riscv.h: 360`)，原则上允许一个进程访问 256 GB 的内存。

一个进程的地址空间由包含程序文本的页面（xv6 使用权限 `PTE_R`、`PTE_X` 和 `PTE_U` 映射）、包含程序的预初始化数据的页面、堆栈的页面以及堆的页面组成。Xv6 使用权限 `PTE_R`、`PTE_W` 和 `PTE_U` 映射数据、堆栈和堆。

在用户地址空间内使用权限是一种常见的加固用户进程的技术。如果 text 与 `PTE_W` 映射，那么进程可能意外地修改自己的程序；例如，编程错误可能导致程序写入空指针，修改地址为 0 的指令，然后继续运行，可能造成更多的破坏。为了立即检测到这种错误，xv6 在没有 `PTE_W` 的情况下映射文本；如果程序意外地尝试存储到地址 0，硬件将拒绝执行存储并引发页面错误（参见第 4.6 节）。然后内核终止进程并打印出有益的消息，以便开发人员可以追踪问题。

同样，通过在没有 `PTE_X` 的情况下映射数据，用户程序无法意外地跳转到程序数据中的地址并从该地址开始执行。

在现实世界中，通过仔细设置权限来加固进程还有助于防御安全攻击。攻击者可能向程序（例如，Web 服务器）提供精心构造的输入，触发程序中的漏洞，希望将该漏洞转变为利用。仔细设置权限和其他技术，例如随机化用户地址空间的布局，使这种攻击变得更加困难。

堆栈是一个单独的页面，并显示为由 exec 创建的初始内容。包含命令行参数的字符串以及指向它们的指针数组位于堆栈的顶部。紧接在下面的是允许程序从 `main` 开始的值，就像刚调用了 `main(argc, argv)` 函数一样。

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p6.png)

为了检测用户栈溢出分配的堆栈内存，xv6 在堆栈下方放置了一个不可访问的保护页面，通过清除 `PTE_U` 标志。如果用户栈溢出并且进程尝试使用堆栈下方的地址，硬件将生成页面错误异常，因为保护页面对用户模式下运行的程序是不可访问的。现实世界的操作系统可能在用户栈溢出时自动为用户栈分配更多内存。

当进程要求 xv6 分配更多用户内存时，xv6 增加进程的堆。Xv6 首先使用  `kalloc`  分配物理页面。然后将 PTE 添加到指向新物理页面的进程页表中。Xv6 在这些 PTE 中设置 `PTE_W`、`PTE_R`、`PTE_U` 和 `PTE_V` 标志。大多数进程不使用整个用户地址空间；xv6 在未使用的 PTE 中保持 `PTE_V` 清除。

这里我们看到了几个很好的使用页表的示例。首先，不同进程的页表将用户地址翻译为不同的物理内存页面，因此每个进程都有私有用户内存。其次，每个进程将其内存视为具有从零开始的连续虚拟地址，而进程的物理内存可以是非连续的。第三，内核在用户地址空间的顶部（没有 `PTE_U`）映射了一个带有跳板代码的页面，因此所有地址空间中的一个物理内存页面仅能被内核使用。



## 代码：sbrk

`sbrk` 是进程缩小或增长其内存的系统调用。系统调用由函数 `growproc` (kernel/proc.c: 260) 实现。根据 `n` 是正数还是负数，`growproc` 调用 `uvmalloc` 或 `uvmdealloc`。 `uvmalloc` (kernel/vm.c:226) 使用 `kalloc` 分配物理内存，并使用 ` mappages` 将 PTE 添加到用户页表。 `uvmdealloc` 调用 `uvmunmap` (kernel/vm.c:171)，它使用 `walk` 查找 PTE 并使用 `kfree` 释放它们所指向的物理内存。

Xv6 使用进程的页表不仅是为了告诉硬件如何映射用户虚拟地址，还作为分配给该进程的物理内存页面的唯一记录。这就是为什么释放用户内存（在 `uvmunmap` 中）需要检查用户页表的原因。

## 代码：exec

`exec` 是一个系统调用，用于将进程的用户地址空间替换为从一个称为二进制文件或可执行文件的文件中读取的数据。二进制文件通常是编译器和链接器的输出，包含机器指令和程序数据。`exec` \(kernel/exec.c:23) 使用 `namei` \(kernel/exec.c:36) 打开名为 `path` 的二进制文件，这在第 8 章中有解释。然后，它读取 ELF 头。Xv6 二进制文件使用广泛使用的 $ELF 格式$，定义在 `kernel/elf.h` 中。一个 ELF 二进制文件由一个 ELF 头部，`struct elfhdr` \(kernel/elf.h:6)，后面跟一系列程序段头部，`struct proghdr` \(kernel/elf.h:25。每个 `progvhdr` 描述了必须加载到内存中的应用程序的一个部分；xv6 程序有两个程序段头部：一个用于指令，一个用于数据。

第一步是快速检查文件可能包含一个 ELF 二进制文件。一个 ELF 二进制文件以四字节的 “魔数” `0x7F`，`E`，`L`，`F` 或 `ELF_MAGIC` \(kernel/elf.h: 3) 开头。如果 ELF 头部具有正确的魔数，`exec` 假定二进制文件是良好的。

`exec` 使用 `proc_pagetable`\(kernel/exec.c:49) 分配没有用户映射的新页表，使用 `uvmalloc`(kernel/exec.c:49) 为每个 ELF 段分配内存，并使用 `loadseg`(kernel/exec.c:10) 将每个段加载到内存中。`loadseg` 使用 `walkaddr` 查找要写入 ELF 段的每一页的分配内存的物理地址，并使用 `readi` 从文件中读取。

`/init` 的程序段头，用 `exec` 创建的第一个用户程序，如下所示：

```bash
# objdump -p user/_init

user/_init:     file format elf64-little

Program Header:
0x70000003 off    0x0000000000006bb0 vaddr 0x0000000000000000
                                       paddr 0x0000000000000000 align 2**0
         filesz 0x000000000000004a memsz 0x0000000000000000 flags r--
    LOAD off    0x0000000000001000 vaddr 0x0000000000000000
                                       paddr 0x0000000000000000 align 2**12
         filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x
    LOAD off    0x0000000000002000 vaddr 0x0000000000001000
                                       paddr 0x0000000000001000 align 2**12
         filesz 0x0000000000000010 memsz 0x0000000000000030 flags rw-
   STACK off    0x0000000000000000 vaddr 0x0000000000000000
                                       paddr 0x0000000000000000 align 2**4
         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
```



我们看到文本段应该加载到内存的虚拟地址 0x0（没有写权限）并且从文件偏移 0x1000 处的内容中加载。我们还看到数据应该加载到地址 0x1000，它位于一个页面边界，且没有可执行权限。

程序段头的 `filesz` 可能小于 `memsz`，表示它们之间的间隙应该用零填充（对于 C 全局变量），而不是从文件中读取。对于 `/init`，数据 `filesz` 为 0x10 字节，`memsz` 为 0x30 字节，因此 `uvmalloc` 为存储 0x30 字节的物理内存分配足够的空间，但仅从文件 `/init` 中读取 0x10 字节。

现在 `exec` 为用户栈分配和初始化内存。它只分配一个栈页。 `exec` 一次将参数字符串复制到栈顶，将指向它们的指针记录在 `ustack` 中。它在传递给 `main` 的 `argv` 列表末尾放置一个空指针。 `ustack` 中的前三个条目是伪返回程序计数器、`argc` 和 `argv` 指针。

`exec` 在栈页下方放置一个不可访问的页，以便尝试使用多于一个页的程序将出错。这个不可访问的页面还允许 `exec` 处理过大的参数；在这种情况下，`exec` 使用的 `copyout` (kernel/vm.c:352) 函数会注意到目标页不可访问，并返回 -1。

在准备新的内存映像期间，如果 `exec` 检测到错误，例如无效的程序段，它将跳转到标签 `bad`，释放新映像，并返回 -1。`exec` 必须等待释放旧映像，直到确定系统调用将成功：如果旧映像消失了，系统调用将无法返回 -1。`exec` 中的唯一错误情况发生在创建映像期间。一旦映像完成，`exec` 可以提交新的页表并释放旧页表。

`exec` 从 ELF 文件中将字节加载到由 ELF 文件指定的地址的内存中。用户或进程可以将任何地址放入 ELF 文件中。因此，`exec` 是有风险的，因为 ELF 文件中的地址可能指向内核，不论是意外还是故意。对于一个不谨慎的内核，后果可能从崩溃到恶意破坏内核的隔离机制（即安全漏洞）。Xv6 执行了许多检查以避免这些风险。例如，`if(ph.vaddr + ph.memsz < ph.vaddr)` 检查求和是否溢出了 64 位整数。危险在于，用户可以构造一个带有指向用户选择的地址的 `ph.vaddr` 的 ELF 二进制文件，以及足够大的 `ph.memsz`，使得求和溢出为 0x1000，这将看起来像一个有效值。在一个旧版本的 xv6 中，用户地址空间也包含了内核（但在用户模式下不可读/写），用户可以选择一个对应于内核内存的地址，并将 ELF 二进制文件中的数据复制到内核中。在 RISC-V 版本的 xv6 中，这是不会发生的，因为内核具有自己的单独页表；`loadseg` 加载到进程的页表中，而不是内核的页表中。

对于内核开发者来说，很容易省略一个关键的检查，现实世界的内核有很长的漏洞检查缺失历史，这种缺失可以被用户程序利用以获得内核权限。很可能 xv6 在验证用户级别数据方面做得不完整，恶意用户程序可能利用它来绕过 xv6 的隔离。

## 现实世界

与大多数操作系统一样，xv6 使用分页硬件进行内存保护和映射。大多数操作系统通过结合分页和页错误异常（我们将在第 4 章中讨论）比 xv6 更复杂地使用分页。

xv6 简化了内核在虚拟地址和物理地址之间使用直接映射的方式，以及假设在地址 0x8000000 处有物理 RAM，内核希望在此处加载。这在 QEMU 上是可行的，但在实际硬件上，这被证明是一个糟糕的主意；实际硬件将 RAM 和设备放置在不可预测的物理地址上，因此（例如）在 0x8000000 处可能没有 RAM，而 xv6 希望在那里存储内核。更严格的内核设计利用页表将任意硬件物理内存布局转换为可预测的内核虚拟地址布局。

RISC-V 支持物理地址级别的保护，但 xv6 没有使用该功能。

对于具有大量内存的机器，使用 RISC-V 支持的“超级页”可能是有意义的。当物理内存较小时，小页有意义，以便以细粒度分配和换页到磁盘。例如，如果一个程序只使用 8KB 的内存，为它分配整个 4MB 的超级页物理内存是浪费的。在具有大量 RAM 的机器上，较大的页可能是有意义的，并且可以减少页表操作的开销。

xv6 内核缺乏一个类似于 `malloc` 的分配器，它可以为小对象提供内存，这阻止了内核使用需要动态分配的复杂数据结构。一个更复杂的内核可能会分配许多不同大小的小块，而不是仅分配 4096 字节的块（如 xv6 中）；一个真正的内核分配器需要处理小分配以及大分配。

内存分配一直是一个热门话题，基本问题是有限内存的有效使用和准备应对未知的未来请求。如今，人们对速度的关注比对空间效率的关注更多。
