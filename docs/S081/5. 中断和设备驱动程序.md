# 5. 中断和设备驱动程序

设备驱动程序（driver）是操作系统中管理特定设备的代码：它配置设备硬件，告知设备执行操作，处理产生的中断，并与可能正在等待设备 I/O 的进程进行交互。驱动程序代码可能会比较棘手，因为驱动程序与其管理的设备是并发执行的。此外，驱动程序必须了解设备的硬件接口，而这些接口可能是很复杂而且文档不够完善的。

需要操作系统关注的设备通常可以配置为生成中断，这是一种 trap 类型。内核 trap 处理代码可以识别设备何时引发中断，并调用驱动程序的中断处理程序；在 xv6 中，此调度发生在 `devintr` (kernel/trap.c:178)。

许多设备驱动程序在两种上下文中执行代码：一种是在进程的内核线程中运行的**上半部**（top half），另一种是在中断时间执行的**下半部**（bottom half）。系统调用（如 `read` 和 `write`）会调用上半部，以便设备执行 I/O。此代码可能会要求硬件启动某个操作（例如，要求磁盘读取一个块）；然后代码等待操作完成。最终，设备完成操作并引发中断。作为下半部的驱动程序的中断处理程序，会找出已完成的操作，如有需要，唤醒等待的进程，并告知硬件开始处理任何等待中的下一个操作。

## 代码：控制台输入

控制台驱动程序 (`kernel/console.c`）是驱动程序结构的一个简单示例。控制台驱动程序通过附加到 RISC-V 的 UART 串口硬件接收由人类输入的字符。控制台驱动程序一次累积一行输入，处理特殊输入字符，如退格键和 control-u。用户进程（如 shell）使用 `read` 系统调用从控制台获取输入行。当您在 QEMU 中输入 xv6 时，您的按键将通过 QEMU 的模拟 UART 硬件传递给 xv6。

驱动程序要与之通信的 UART 硬件是由 QEMU 模拟的 16550 芯片（参考文献 \[ns16550a\]）。在实际计算机上，16550 会管理一个连接到终端或其他计算机的 RS232 串行链接。在运行 QEMU 时，它连接到您的键盘和显示器。

UART 硬件对软件呈现为一组**内存映射**（memory-mapped）控制寄存器。也就是说，有一些物理地址被 RISC-V 硬件连接到 UART 设备，因此加载和存储与设备硬件进行交互，而不是与 RAM 进行交互。UART 的内存映射地址从 0x10000000 开始，即 `UART0`(kernel/memlayout.h:21）。有一些 UART 控制寄存器，每个寄存器宽一个字节。它们相对于 `UART0` 的偏移量定义在(kernel/uart.c:22)。例如，`LSR` 寄存器包含指示是否有输入字符等待软件读取的位。这些字符（如果有）可以从 `RHR` 寄存器读取。每读取一个字符，UART 硬件就会从内部 FIFO 中删除等待的字符，并在 FIFO 为空时清除 `LSR` 中的“ready”位。UART 发送硬件与接收硬件大致独立；如果软件将一个字节写入 `THR`，UART 将发送该字节。

xv6 的 `main` 调用 `consoleinit`(kernel/console.c:182)来初始化 UART 硬件。此代码配置 UART 在接收每个输入字节时生成接收中断，并在 UART 完成发送每个输出字节时生成**传输完成**（transmit complete) 中断 (kernel/uart.c:53)。

xv6 shell 通过 `init.c` 打开的文件描述符从控制台读取(user/init.c:19)。对 `read` 系统调用的调用通过内核传递给 `consolere`读取(kernel/console.c:80)。`consoleread` 等待输入通过中断到达并缓存在 `cons.buf` 中，将输入复制到用户空间，然后（在整行到达后）返回到用户进程。如果用户尚未输入完整的一行，任何正在读取的进程将在 `sleep` 调用中等待(kernel/console.c:96）（第 7 章解释了 `sleep` 的详细信息）。

当用户输入一个字符时，UART 硬件要求 RISC-V 引发中断，从而激活 xv6 的 trap 处理程序。 trap 处理程序调用 `devintr`(kernel/trap.c:178)，它查看 RISC-V 的 `scause` 寄存器以发现中断是来自外部设备。然后，它要求名为 PLIC 的硬件单元告诉它哪个设备发出了中断(kernel/trap.c:187)。如果是 UART，`devintr` 就会调用 `uartintr`。

`uartintr`(kernel/uart.c:176) 从 UART 硬件读取任何等待的输入字符，并将它们传递给 `consoleintr`(kernel/console.c:136)；它不会等待字符，因为将来的输入将引发新的中断。`consoleintr` 的任务是在 `cons.buf` 中累积输入字符，直到整行到达。`consoleintr` 对退格键和其他一些特殊字符进行特殊处理。当换行符到达时，`consoleintr` 会唤醒等待的 `consoleread`（如果有的话）。

一旦唤醒，`consoleread` 会在 `cons.buf` 中观察到完整的一行，将其复制到用户空间，并通过系统调用机制返回到用户空间。

## 代码：控制台输出

在连接到控制台的文件描述符上执行的 `write` 系统调用最终会到达 `uartputc`(kernel/uart.c:87）。设备驱动程序维护一个输出缓冲区（`uart_tx_buf`），以便写入进程不必等待 UART 完成发送；相反，`uartputc` 将每个字符附加到缓冲区，调用 `uartstart` 开始设备传输（如果尚未开始），然后返回。唯一需要 `uartputc` 等待的情况是缓冲区已满。

每次 UART 完成发送一个字节时，它会生成一个中断。`uartintr` 调用 `uartstart`，检查设备确实已完成发送，并将下一个缓冲输出字符交给设备。因此，如果进程向控制台写入多个字节，通常第一个字节将由 `uartputc` 对 `uartstart` 的调用发送，剩余的缓冲字节将由 `uartintr` 在传输完成中断到达时从 `uartstart` 调用发送。

需要注意的一般模式是通过缓冲和中断将设备活动与进程活动解耦。即使没有进程等待读取，控制台驱动程序也可以处理输入；后续的读取将看到输入。类似地，进程可以在不必等待设备的情况下发送输出。这种解耦可以通过允许进程与设备 I/O 并发执行来提高性能，尤其是当设备速度较慢（如 UART）或需要立即关注（如回显输入字符）时。这个想法有时被称为 I/O 并发。

## 驱动程序中的并发

您可能已经注意到 `consoleread` 和 `consoleintr` 中的 `acquire` 调用。这些调用获取一个锁，该锁保护控制台驱动程序的数据结构免受并发访问。这里有三个并发危险：不同 CPU 上的两个进程可能同时调用 `consoleread`；硬件可能在 CPU 已经在 `consoleread` 内部执行时要求 CPU 传递一个控制台（实际上是 UART）中断；在执行 `consoleread` 时，硬件可能在不同的 CPU 上传递控制台中断。这些危险可能导致竞争或死锁。第 6 章探讨了这些问题以及锁如何解决它们。

驱动程序中需要注意的另一种并发问题是，一个进程可能在等待来自设备的输入，但在不同进程（或根本没有进程）运行时，表示输入到达的中断可能会到达。因此，中断处理程序不允许考虑它们中断的进程或代码。例如，中断处理程序不能使用当前进程的页表安全地调用 `copyout`。中断处理程序通常做相对较少的工作（例如，只将输入数据复制到缓冲区），并唤醒上半部分代码来完成其余工作。

## 定时器中断

Xv6 使用定时器中断来维护其时钟并使其能够在计算密集型进程之间切换；`usertrap` 和 `kerneltrap` 中的 `yield` 调用导致了这种切换。定时器中断来自连接到每个 RISC-V CPU 的时钟硬件。Xv6 编程使这个时钟硬件定期中断每个 CPU。

RISC-V 要求在机器模式而不是监督模式中采取定时器中断。RISC-V 机器模式在无分页的情况下执行，并使用一组单独的控制寄存器，因此在机器模式下运行普通的 xv6 内核代码是不切实际的。因此，xv6 完全独立于上述 trap 机制来处理定时器中断。

在 `start.c` 中以机器模式执行的代码，在 `main` 之前，设置接收定时器中断 (kernel/start.c:63)。部分工作是编程 CLINT 硬件（核心本地中断器）在一定延迟后生成中断。另一部分是设置一个类似于 trapframe 的临时区域，以帮助定时器中断处理程序保存寄存器和 CLINT 寄存器的地址。最后，`start` 将 `mtvec` 设置为 `timervec` 并启用定时器中断。

当用户或内核代码正在执行时，定时器中断可以在任何时候发生；内核无法在关键操作期间禁用定时器中断。因此，定时器中断处理程序必须以不干扰中断内核代码的方式执行其任务。基本策略是让处理程序请求 RISC-V 发起“软件中断”，然后立即返回。RISC-V 使用普通的 trap 机制将软件中断发送到内核，并允许内核禁用它们。处理由定时器中断生成的软件中断的代码可以在 `devintr` (kernel/trap.c:205) 中看到。

机器模式定时器中断处理程序是 `timervec` (kernel/kernelvec.S:95)。它在 `start` 准备的临时区域中保存了一些寄存器，告诉 CLINT 何时生成下一个定时器中断，要求 RISC-V 发起一个软件中断，恢复寄存器并返回。定时器中断处理程序中没有 C 代码。

## 现实世界

Xv6 在执行内核时以及执行用户程序时允许设备和定时器中断。定时器中断会强制从定时器中断处理程序进行线程切换（调用 `yield`），即使在执行内核时也是如此。如果内核线程有时花费大量时间进行计算而不返回到用户空间，那么在内核线程之间公平地分割 CPU 时间将非常有用。然而，内核代码需要注意它可能会被挂起（由于定时器中断）并在稍后的不同 CPU 上恢复，这是 xv6 的一些复杂性的来源(第 6.6 节）。如果设备和定时器中断仅在执行用户代码时发生，内核可能会更简单一些。

在典型计算机上支持所有设备的全部功能需要做很多工作，因为设备很多，设备具有很多功能，并且设备和驱动程序之间的协议可能很复杂且记录不完善。在许多操作系统中，驱动程序代码比核心内核代码还多。

UART 驱动程序通过读取 UART 控制寄存器一次读取一个字节的数据；这种模式称为`编程式 I/O`，因为软件正在驱动数据移动。编程式 I/O 很简单，但对于高数据速率来说太慢了。需要以高速移动大量数据的设备通常使用`直接内存访问`（DMA）。DMA 设备硬件直接将传入数据写入 RAM，并从 RAM 中读取传出数据。现代磁盘和网络设备使用 DMA。DMA 设备的驱动程序会在 RAM 中准备数据，然后使用单次写入控制寄存器的操作告诉设备处理准备好的数据。

当设备需要在不可预测的时间关注，并且不是太频繁时，中断是有意义的。但是中断具有很高的 CPU 开销。因此，高速设备（如网络和磁盘控制器）使用减少中断需求的技巧。一个技巧是为一整批传入或传出请求引发单个中断。另一个技巧是驱动程序完全禁用中断，并定期检查设备以查看是否需要关注。这种技术称为`轮询`。如果设备执行操作非常快，轮询是有意义的，但是如果设备大部分时间处于空闲状态，它会浪费 CPU 时间。一些驱动程序会根据当前设备负载动态在轮询和中断之间切换。

UART 驱动程序首先将传入数据复制到内核中的缓冲区，然后复制到用户空间。在低数据速率下，这种做法是合理的，但对于生成或消耗数据非常快的设备来说，这种双重复制可能会显著降低性能。有些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用 DMA。

正如第 1 章中提到的，控制台对应用程序显示为一个常规文件，应用程序使用 read 和 write 系统调用读取输入和写入输出。应用程序可能需要控制设备的某些方面，而这些方面无法通过标准的文件系统调用来表达（例如，在控制台驱动程序中启用/禁用行缓冲）。Unix 操作系统为此类情况支持 ioctl 系统调用。

计算机的某些用途需要系统在有限的时间内做出响应。例如，在安全关键的系统中，错过截止日期可能导致灾难。Xv6 不适用于硬实时设置。用于硬实时的操作系统往往是与应用程序链接的库，以便分析确定最坏情况下的响应时间。Xv6 也不适用于软实时应用，因为偶尔错过截止日期是可以接受的，原因是 xv6 的调度程序过于简单，且内核代码路径中长时间禁用中断。