# 4. trap 与系统调用

CPU 在遇到以下三种事件时会中止正常的指令执行，并强制将控制权转移到处理该事件的特殊代码。

- 一种情况是**系统调用**，当用户程序执行 `ecall` 指令以请求内核为其执行操作时。
- 另一种情况是**异常**：指令（用户或内核）执行非法操作，例如除以零或使用无效的虚拟地址。
- 第三种情况是**设备中断**，当设备发出需要关注的信号时，例如磁盘硬件完成读或写请求。

本书将这些情况统称为 **trap** 。通常，trap 发生时的代码后续会需要恢复，并且不需要意识到发生了任何特殊的事情。也就是说，我们通常希望 trap 是透明的；这对设备中断尤其重要，因为被中断的代码通常不会预料到这种情况。通常的顺序是 trap 迫使控制权转移到内核；内核保存寄存器和其他状态以便恢复执行；内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）；内核恢复已保存的状态并从 trap 返回；原始代码从中断处恢复。

Xv6 在内核中处理所有 trap；trap 不会传递给用户代码。对于系统调用，这种在内核中处理 trap 的方式是很自然的。对于中断，这是有道理的，因为隔离要求只允许内核使用设备，以及因为内核是在多个进程之间共享设备的便捷机制。对于异常，这也是有道理的，因为 xv6 会对来自用户空间的所有异常进行响应并终止相关程序。

Xv6 的 trap 处理分为四个阶段：

- RISC-V CPU 执行的硬件操作
- 一些汇编指令准备内核 C 代码的方式
- 决定如何处理trap的 C 函数
- 以及系统调用或设备驱动程序的服务例程

尽管三种 trap 类型之间的相似性表明内核可以使用单一的代码路径处理所有 trap，但实际上，对于三个明确的情况（来自用户空间的 trap、来自内核空间的 trap 和 定时器中断）具有独立的代码是很方便的。处理 trap 的内核代码（汇编或 C 语言）通常称为 **handler** ；第一个处理程序指令通常以汇编（而非 C 语言）编写，有时被称为 **vector**。

## RISC-V trap机制

每个 RISC-V CPU 都有一组控制寄存器，内核可以写入这些寄存器以告知 CPU 如何处理trap，也可以读取这些寄存器以了解已发生的 trap。RISC-V 文档包含了完整的信息。`riscv.h` (kernel/riscv.h:1) 包含了 xv6 使用的定义。以下是最重要的寄存器概述：

- **stvec**：内核将其 trap 处理程序的地址写入此处；RISC-V 在处理 trap 时跳转到 **stvec** 中的地址。
- **sepc**：当 trap 发生时，RISC-V 将程序计数器保存在此处（因为 pc 随后被  stvec 中的值覆盖）。 sret（从trap返回）指令将 sepc 复制到 pc。内核可以写入  sepc 以控制  sret 的跳转位置。
- **scause**：RISC-V 将描述 trap 原因的数字放在这里。
- **sscratch**：trap 处理程序代码使用  sscratch 来帮助它在保存用户寄存器之前避免覆盖它们。
- **sstatus**： sstatus 中的 SIE 位控制设备中断是否启用。如果内核清除 SIE 位，则 RISC-V 将推迟设备中断，直到内核设置 SIE 位。SPP 位表示 trap 是从用户模式还是监视器模式发出的，并控制 sret 返回到哪个模式。

上述寄存器与在监视器模式下处理的 trap 相关，而在用户模式下无法读取或写入它们。还有一组类似的控制寄存器用于在机器模式下处理 trap；xv6 仅将它们用于定时器中断的特殊情况。

一个多核芯片上的每个 CPU 都有这些寄存器的一组，而且在任何给定时间，可能有多个 CPU 正在处理 trap。

当需要强制 trap 时，除定时器中断外，RISC-V 硬件对所有 trap 类型执行以下操作：

1. 如果 trap 是设备中断，并且 sstatus 的 SIE 位已清除，则不执行以下任何操作。
2. 通过清除 sstatus 中的 SIE 位禁用中断。
3. 将 pc 复制到 sepc。
4. 在  sstatus 中的 SPP 位保存当前模式（用户或监视器）。
5. 将 scause 设置为反映 trap 的原因。
6. 将模式设置为监督者。
7. 将 stvec 复制到 pc。
8. 在新的 pc 处开始执行。

请注意，CPU 不会切换到内核页表，不会切换到内核中的堆栈，也不会保存除  pc 以外的任何寄存器。内核软件必须执行这些任务。在 trap 期间，CPU 执行最少的工作是为了提供软件的灵活性；例如，某些操作系统在某些情况下省略页面表切换以提高trap性能。

值得思考的是，上面列出的步骤中是否有任何步骤可以省略，也许是为了寻求更快的trap。虽然在某些情况下可以使用更简单的序列，但在一般情况下，省略许多步骤可能是危险的。例如，假设 CPU 不切换程序计数器。那么从用户空间发出的 trap 可能在仍在运行用户指令的情况下切换到监视器模式。这些用户指令可能会破坏用户/内核隔离，例如通过修改 satp 寄存器指向允许访问所有物理内存的页表。因此，CPU 切换到内核指定的指令地址（即  stvec）是非常重要的。

## 从用户空间的trap

Xv6 根据 trap 发生在内核代码还是用户代码中的情况进行不同的处理。这里讲述的是从用户代码发生的 trap；第 4.5 节描述了从内核代码发生的 trap。

当在用户空间执行时，用户程序发起系统调用（`ecall` 指令），或执行非法操作，或设备中断时，可能会发生 trap。从用户空间的 trap 的处理路径是：

- `uservec`(kernel/trampoline.S:21)，
- 然后是 `usertrap`(kernel/trap.c:37)；
- 返回时，执行 `usertrapret`(kernel/trap.c:90)
- 然后执行 `userret`(kernel/trampoline.S:101)。

xv6 的 trap 处理设计的一个主要约束是 RISC-V 硬件在强制 trap 时不切换页表。这意味着 `stvec` 中的 trap 处理程序地址必须在用户页表中具有有效映射，因为当 trap 处理代码开始执行时，该页表是有效的。此外，xv6 的 trap 处理代码需要切换到内核页表；为了在切换后能够继续执行，内核页表还必须为 `stvec` 指向的处理程序提供映射。

Xv6 使用一个***trampoline***页面来满足这些要求。*trampoline* 页面包含 `uservec`，即 `stvec` 指向的 xv6 trap 处理代码。跳板页面在每个进程的页表中映射到地址 `TRAMPOLINE`，该地址位于虚拟地址空间的顶部，以便位于程序自己使用的内存之上。跳板页面也映射到内核页表中的地址 `TRAMPOLINE`。请参见图2.3 和图3.3 。由于跳板页面映射到用户页表中，没有 `PTE_U` 标志，trap 可以在监视器模式下开始执行。由于跳板页面在内核地址空间中映射到相同的地址，trap 处理程序可以在切换到内核页表后继续执行。

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c2/p2.png)



![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p3.png)

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p4.png)

`uservec` trap处理程序的代码位于 `trampoline.S`(kernel/trampoline.S:21)。当 `uservec` 开始时，所有 32 个寄存器都包含中断用户代码的值。这些 32 个值需要保存到内存的某个地方，以便在 trap 返回到用户空间时可以恢复。存储到内存需要使用一个寄存器来保存地址，但在这一点上没有通用寄存器可用! 幸运的是，RISC-V 提供了一个帮助手，即 `sscratch` 寄存器。`uservec` 开始时的 `csrw` 指令将 `a0` 保存在 `sscratch` 中。现在 `uservec` 有一个可用的寄存器（`a0`）。

`uservec` 的下一个任务是保存 32 个用户寄存器。内核为每个进程分配一个内存页来存储 `trapframe` 结构，该结构（除其他外）有空间保存 32 个用户寄存器(kernel/proc.h:43)。因为 `satp` 仍然引用用户页表，`uservec` 需要将 trapframe 映射到用户地址空间。Xv6 在每个进程的用户页表中将其 trapframe 映射到虚拟地址 `TRAPFRAME`；`TRAPFRAME` 位于 `TRAMPOLINE` 下方。进程的 `p->trapframe` 也指向 trapframe，不过是以其物理地址表示，以便内核通过内核页表使用它。

因此，`uservec` 将地址 `TRAPFRAME` 加载到 `a0` 中并将所有用户寄存器保存在那里，包括从 `sscratch` 读回的用户的 `a0`。

`trapframe` 包含当前进程的内核栈地址、当前 CPU 的 `hartid`、`usertrap` 函数的地址以及内核页表的地址。`uservec` 检索这些值，切换到内核页表，然后调用 `usertrap`。

`usertrap` 的任务是确定 trap 的原因，处理它并返回(kernel/trap.c:37)。它首先将 `stvec` 更改为在内核中的 trap 由 `kernelvec` 而不是 `uservec` 处理。它保存 `sepc` 寄存器（保存的用户程序计数器），因为 `usertrap` 可能会调用 `yield` 切换到另一个进程的内核线程，该进程可能返回到用户空间，其过程中会修改 `sepc`。如果 trap 是系统调用，`usertrap` 调用 `syscall` 来处理它；如果是设备中断，则调用 `devintr`；否则是异常，内核将杀死出错的进程。系统调用路径会在保存的用户程序计数器上加 4，因为 RISC-V 在系统调用的情况下，将程序指针指向 `ecall` 指令，但用户代码需要在后续指令处恢复执行。在返回之前，`usertrap` 检查进程是否已被杀死或应该放弃 CPU（如果此 trap 是计时器中断）。

返回用户空间的第一步是调用 `usertrapret`(kernel/trap.c:90)。此函数设置 RISC-V 控制寄存器，为将来从用户空间发生的 trap 做准备。这包括更改 `stvec` 以引用 `uservec`，准备 `uservec` 依赖的 trapframe 字段，并将 `sepc` 设置为之前保存的用户程序计数器。最后，`usertrapret` 在用户和内核页表中都映射的 trampoline 页上调用 `userret`；原因是 `userret` 中的汇编代码将切换页表。

`usertrapret` 对 `userret` 的调用通过 `a0` 传递指向进程用户页表的指针(kernel/trampoline.S:101)。`userret` 将 `satp` 切换到进程的用户页表。回想一下，用户页表映射了 trampoline 页面和 `TRAPFRAME`，但没有映射内核的其他内容。trampoline 页在用户和内核页表中的相同虚拟地址允许 `userret` 在更改 `satp` 后继续执行。从这一点开始，`userret` 唯一可以使用的数据是寄存器内容和 trapframe 的内容。`userret` 将 `TRAPFRAME` 地址加载到 `a0`，通过 `a0` 从 trapframe 恢复保存的用户寄存器，恢复保存的用户 `a0`，并执行 `sret` 返回到用户空间。



## 代码：调用系统调用

第 2 章在`initcode.S` 使用`exec`系统调用(user/initcode.S:11)结束。让我们看看用户调用如何到达内核中`exec`系统调用的实现。

在 `initcode.S` 中，`exec`的参数放在寄存器`a0`和`a1`中，并将系统调用编号放入`a7`。系统调用编号与`syscalls`数组中的条目相匹配，该数组是函数指针的表(kernel/syscall.c:107)。`ecall`指令陷入内核并导致`uservec`、`usertrap`和`syscall`按照我们之前所看到的顺序执行。

`syscall`(kernel/syscall.c:132)从 trapframe 中保存的 a7 中检索系统调用编号，并用它索引`syscalls`。对于第一个系统调用，a7 包含`SYS_exec`(kernel/syscall.h:8)，从而调用系统调用实现函数`sys_exec`。

当 `sys_exec` 返回时，`syscall` 将其返回值记录在 `p->trapframe->a0` 中。这将导致原始用户空间对`exec()`的调用返回该值，因为 RISC-V 上的 C 调用约定将返回值放在 `a0` 中。系统调用通常返回负数以表示错误，返回零或正数表示成功。如果系统调用编号无效，`syscall` 会打印错误并返回$-1$。

## 代码：系统调用参数

内核中的系统调用实现需要找到用户代码传递的参数。因为用户代码调用系统调用包装函数，所以参数最初位于 RISC-V C 调用约定将其放置的寄存器中。内核trap代码将用户寄存器保存到当前进程的trap帧中，内核代码可以在那里找到它们。内核函数 `argint`、`argaddr` 和 `argfd` 从trap帧中检索第  n 个系统调用参数，作为整数、指针或文件描述符。它们都调用 `argraw` 来检索适当的保存的用户寄存器(kernel/syscall.c:34)。

有些系统调用传递指针作为参数，内核必须使用这些指针来读取或写入用户内存。例如，`exec` 系统调用将一个指针数组传递给内核，这些指针引用用户空间中的字符串参数。这些指针带来了两个挑战。首先，用户程序可能有缺陷或恶意，并且可能向内核传递无效指针或旨在欺骗内核访问内核内存而非用户内存的指针。其次，xv6 内核页表映射与用户页表映射不同，因此内核不能使用普通指令从用户提供的地址加载或存储。

内核实现了可以安全地将数据传输到和从用户提供的地址的函数。`fetchstr` 是一个例子(kernel/syscall.c:25)。诸如 `exec` 之类的文件系统调用使用 `fetchstr` 从用户空间检索字符串文件名参数。`fetchstr` 调用 `copyinstr` 来完成繁重的工作。

`copyinstr`(kernel/vm.c:403) 从用户页表 `pagetable` 中的虚拟地址 `srcva` 复制至多 `max` 字节到 `dst`。由于 `pagetable` 不是当前页表，`copyinstr` 使用 `walkaddr`（调用 `walk`）在 `pagetable` 中查找 `srcva`，得到物理地址 `pa0`。内核将每个物理 RAM 地址映射到相应的内核虚拟地址，因此 `copyinstr` 可以直接从 `pa0` 复制字符串字节到 `dst`。`walkaddr` (kernel/vm.c:109) 检查用户提供的虚拟地址是否是进程的用户地址空间的一部分，因此程序不能欺骗内核读取其他内存。

## 内核空间的trap

根据用户或内核代码是否在执行，Xv6 对 CPU trap寄存器的配置略有不同。当内核在 CPU 上执行时，内核将 `stvec` 指向汇编代码 `kernelvec` (kernel/kernelvec.S:12) 。由于 xv6 已经在内核中，`kernelvec` 可以依赖于 `satp` 被设置为内核页表，并且栈指针指向有效的内核栈。`kernelvec` 将所有 32 个寄存器压入栈中，以便稍后从中恢复它们，这样被中断的内核代码可以在不受干扰的情况下恢复。

`kernelvec` 将寄存器保存在被中断的内核线程的栈上，这是有道理的，因为寄存器值属于那个线程。如果trap导致切换到另一个线程，这尤其重要 -- 在这种情况下，trap实际上会从新线程的栈返回，使被中断的线程的已保存寄存器安全地留在其栈上。

在保存寄存器之后，`kernelvec` 跳转到 `kerneltrap` (kernel/trap.c:135)。`kerneltrap` 准备处理两种类型的 trap：设备中断和异常。它调用 `devintr` (kernel/trap.c:178) 来检查并处理前者。如果 trap 不是设备中断，那么它一定是异常，在 xv6 内核中这总是一个致命错误；内核调用 `panic` 并停止执行。

如果由于定时器中断而调用了 `kerneltrap`，并且一个进程的内核线程正在运行（而不是调度器线程），`kerneltrap` 调用 `yield` 以给其他线程一个运行的机会。在某个时刻，其中一个线程会让步，并让我们的线程和它的 `kerneltrap` 再次恢复。第 7 章解释了在 `yield` 中发生了什么。

当 `kerneltrap` 完成工作时，它需要返回到被 trap 中断的代码。由于 `yield` 可能已经干扰了 `sepc` 和 `sstatus` 中的先前模式，因此 `kerneltrap` 在启动时保存它们。现在它恢复这些控制寄存器并返回到 `kernelvec`（kernel/kernelvec.S:50）。`kernelvec` 从堆栈中弹出保存的寄存器并执行 `sret`，将 `sepc` 复制到 `pc` 并恢复中断的内核代码。

值得考虑的是，如果 `kerneltrap` 由于计时器中断而调用了 `yield`， trap 返回是如何发生的。

当 CPU 从用户空间进入内核时，Xv6 将 CPU 的 `stvec` 设置为 `kernelvec`；您可以在 `usertrap`（kernel/trap.c:29）中看到这一点。 在内核开始执行但 `stvec` 仍设置为 `uservec` 的时间窗口中，至关重要的是在该窗口期间不要发生设备中断。 幸运的是，当 RISC-V 开始处理 trap 时，它总是禁用中断，而 xv6 直到设置 `stvec` 之后才再次启用它们。



## 页错误异常

Xv6 对异常的响应相当简单：如果异常发生在用户空间，内核将终止出错的进程。如果异常发生在内核中，内核将发生恐慌。实际的操作系统通常以更有趣的方式进行响应。

以许多内核使用的页错误来实现 copy-on-write（COW）fork 为例。为了解释写时复制 fork ，考虑在第 3 章中描述的 xv6 的 `fork`。 `fork` 使子进程的初始内存内容与 fork 时父进程的内容相同。Xv6 使用 `uvmcopy`(kernel/vm.c:306) 来实现，它为子进程分配物理内存，并将父进程的内存复制到其中。如果子进程和父进程可以共享父进程的物理内存，那将更高效。然而，这样的实现不起作用，因为它会导致父进程和子进程在共享堆栈和堆上的写入相互干扰。

通过适当使用页表权限和页错误，父进程和子进程可以安全地共享物理内存。当虚拟地址在页表中没有映射，或者具有映射但其 `PTE_V`) 标志被清除，或者映射的权限位（`PTE_R`，`PTE_W`，`PTE_X`，`PTE_U`）禁止正在尝试的操作时，CPU 会引发 *page-fault exception*。RISC-V 区分三种类型的页错误：

- 加载页错误（当加载指令无法转换其虚拟地址时）
- 存储页错误（当存储指令无法转换其虚拟地址时）
- 以及指令页错误（当程序计数器中的地址无法转换时）

`scause` 寄存器指示页错误的类型，`stval` 寄存器包含无法转换的地址。

COW fork 的基本设计是，父进程和子进程最初共享所有物理页，但每个进程都将它们映射为只读（清除 `PTE_W` 标志）。父进程和子进程可以从共享的物理内存中读取。如果任一进程写入给定页，RISC-V CPU 会引发页错误异常。内核的 trap 处理程序会响应分配一个新的物理内存页，并将故障地址映射到的物理页复制到其中。内核更改故障进程的页表中的相关 PTE 以指向副本，并允许读写操作，然后在引起故障的指令处恢复故障进程。因为 PTE 允许写入，所以重新执行的指令现在可以在没有错误的情况下执行。写时复制需要进行记录以帮助确定何时可以释放物理页，因为每个页面可以根据 fork 、页面错误、执行和退出的历史记录由多个页面表引用。这种记录允许一个重要的优化：如果一个进程发生存储页面错误，并且物理页面只从该进程的页面表中引用，就不需要复制。

写时复制使 `fork` 更快，因为 `fork` 不需要复制内存。部分内存稍后需要在写入时复制，但通常情况下，大部分内存永远不需要复制。一个常见的例子是 `fork` 后跟 `exec`：在 `fork` 之后可能会写入几个页面，但随后子进程的 `exec` 会释放从父进程继承的大部分内存。写时复制 `fork` 消除了对这些内存复制的需求。此外，COW  fork 是透明的：对应用程序进行修改以使它们受益是不必要的。

页表和页错误的组合为除 COW  fork 之外的有趣功能提供了广泛的可能性。另一个广泛使用的功能称为 *lazy allocation*，分为两部分。首先，当应用程序通过调用 `sbrk` 请求更多内存时，内核记录大小的增加，但不分配物理内存，也不为新的虚拟地址范围创建 PTE。其次，在对这些新地址的页面错误上，内核分配一个物理内存页面并将其映射到页面表中。与 COW  fork 一样，内核可以透明地实现延迟分配(lazy allocation)。

由于应用程序经常请求比它们需要的更多内存，延迟分配(lazy allocation)是一个优势：对于应用程序永远不使用的页面，内核根本不需要做任何工作。此外，如果应用程序要求增加很多地址空间，那么没有延迟分配(lazy allocation)的 `sbrk` 是昂贵的：如果应用程序请求一千兆字节的内存，内核必须分配和清零 262,144 个 4096 字节的页面。延迟分配(lazy allocation)允许此成本分摊。另一方面，延迟分配(lazy allocation)会导致页面错误的额外开销，这涉及内核/用户转换。操作系统可以通过每个页面错误分配一批连续页面而不仅分配一个页面来减少页错误的开销。

另一个广泛使用的特性是利用页错误实现的**按需分页** (*demand paging*)。在`exec`中，xv6 将应用程序的所有文本和数据立即加载到内存中。由于应用程序可能很大且从磁盘读取代价高昂，这种启动成本可能会被用户察觉到：当用户从 shell 启动大型应用程序时，在用户看到响应之前可能需要很长时间。为了提高响应速度，现代内核会为用户地址空间创建页表，但将页面的 PTE 标记为无效。在发生页错误时，内核从磁盘读取页面内容并将其映射到用户地址空间。与 COW  fork 和延迟分配(lazy allocation)一样，内核可以透明地实现这个功能。

在计算机上运行的程序可能需要比计算机具有的 RAM 更多的内存。为了应对这种情况，操作系统可以实现**磁盘分页** (*paging to disk*)。其思想是仅将用户页面的一部分存储在 RAM 中，其余部分存储在磁盘上的**分页区域**(*paging area*)。内核将对应于分页区域中存储的内存（因此不在 RAM 中）的 PTE 标记为无效。如果应用程序尝试使用已经**换出**(*paged out*)到磁盘的页面，应用程序将产生页错误，页面必须**换入**(*paged in*)：内核trap处理程序将分配一个物理 RAM 页面，将页面从磁盘读取到 RAM 中，并修改相关 PTE 指向 RAM。

如果需要换入页面，但没有可用的物理 RAM 怎么办？在这种情况下，内核必须先通过将页面换出或**驱逐**(*evicting*)到磁盘上的分页区域来释放物理页面，并将引用该物理页面的 PTE 标记为无效。驱逐操作代价高昂，所以分页性能最佳的情况是它很少发生：如果应用程序只使用它们内存页面的一个子集，并且子集的并集适应于 RAM。这个属性通常被称为具有良好的局部性引用。与许多虚拟内存技术一样，内核通常以对应用程序透明的方式实现磁盘分页。

计算机通常在几乎没有**可用**物理内存的情况下运行，无论硬件提供了多少 RAM。例如，云提供商在单台机器上复用许多客户，以有效地使用硬件。另一个例子是，用户在较少的物理内存中运行许多智能手机应用程序。在这种环境中，分配页面可能需要先驱逐现有页面。因此，当可用物理内存稀缺时，分配页面是昂贵的。

当可用内存稀缺时，延迟分配(lazy allocation)和按需分页尤其有优势。在`sbrk`或`exec`中预先分配内存会导致额外的驱逐成本以释放内存。此外，预先分配的工作可能会被浪费，因为在应用程序使用页面之前，操作系统可能已经将其驱逐。

其他将分页和页错误异常结合在一起的功能包括自动扩展堆栈和内存映射文件。

## 实际应用

弹簧板和trap帧可能看起来过于复杂。一个驱动力是 RISC-V 故意在强制 trap 时尽量做得很少，以允许非常快速的 trap 处理，这实际上非常重要。因此，内核trap处理程序的前几条指令实际上必须在用户环境中执行：用户页表和用户寄存器内容。并且 trap 处理程序最初对有用的事实（如正在运行的进程的身份或内核页表的地址）一无所知。由于 RISC-V 提供了受保护的地方，内核在进入用户空间之前可以将信息存储起来：`sscratch` 寄存器，以及指向内核内存的用户页表条目，但受到缺少 `PTE_U` 的保护。Xv6 的弹簧板和 trap 帧利用了这些 RISC-V 功能。

如果将内核内存映射到每个进程的用户页表中（具有适当的 PTE 权限标志），则可以消除对特殊弹簧板页面的需求。这也将消除在从用户空间陷入内核时切换页表的需求。反过来，这将允许内核中的系统调用实现利用当前进程的用户内存被映射的优势，从而允许内核代码直接解引用用户指针。许多操作系统已经使用这些想法来提高效率。Xv6 避免使用它们，以减少内核中由于意外使用用户指针而导致的安全漏洞的可能性，并减少确保用户和内核虚拟地址不重叠所需的一些复杂性。

生产操作系统实现了写时复制 fork 、延迟分配(lazy allocation)、按需分页、磁盘分页、内存映射文件等功能。此外，生产操作系统会尽量使用所有物理内存，无论是用于应用程序还是缓存（例如，文件系统的缓冲区缓存，我们将在第 8.2 节中介绍）。在这方面，Xv6 相当简单：你希望你的操作系统使用你购买的物理内存，但 xv6 并没有这样做。此外，如果 xv6 内存耗尽，它会向正在运行的应用程序返回错误或杀死它，而不是例如驱逐另一个应用程序的页面。