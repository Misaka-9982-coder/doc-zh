# 9. 再次探讨并发性

在内核设计中，同时获得良好的并行性能、尽管存在并发性也能保持正确性以及可理解的代码是一个巨大的挑战。直接使用锁是实现正确性的最佳途径，但并不总是可行的。本章重点介绍了xv6在使用锁方面被迫采用复杂方法的例子，以及xv6使用类似锁的技术但不使用锁的例子。

## 锁定模式

缓存的项目通常是锁定的挑战。例如，文件系统的块缓存(ker- nel/bio.c:26) 存储了多达 `NBUF` 个磁盘块的副本。对于给定的磁盘块在缓存中最多只能有一个副本至关重要；否则，不同的进程可能对本应相同的块进行冲突的更改。每个缓存的块都存储在一个 `struct buf`(kernel/buf.h:1).中。一个 `struct buf` 有一个锁定字段，有助于确保一次只有一个进程使用给定的磁盘块。然而，这个锁还不够：如果一个块根本不在缓存中，而两个进程同时想要使用它怎么办？由于该块尚未缓存，因此没有 `struct buf`，也没有锁定的对象。Xv6 通过将一个额外的锁（`bcache.lock`）与缓存块的一组标识关联来处理这种情况。需要检查一个块是否被缓存的代码（例如 `bget`  (kernel/bio.c:59)),，或者更改缓存块集，必须持有 `bcache.lock`；在该代码找到所需的块和 `struct buf` 之后，它可以释放 `bcache.lock` 并锁定特定的块。这是一种常见的模式：一组项目有一个锁，每个项目有一个锁。

通常，获取锁的同一个函数将释放它。但是，更精确的观点是，锁定是在必须看起来是原子的序列的开始处获得的，并在该序列结束时释放。如果序列在不同的函数、不同的线程或不同的 CPU 上开始和结束，那么锁定获取和释放也必须如此。锁的功能是强制其他用途等待，而不是将数据固定到特定的代理。一个例子是 `yield` 中的 `acquire`(kernel/proc.c:503)，它在调度器线程中释放，而不是在获取进程中。另一个例子是 `ilock` (kernel/fs.c:293)中的 `acquiresleep`；这段代码在读取磁盘时经常休眠；它可能在不同的 CPU 上唤醒，这意味着锁可能在不同的 CPU 上获取和释放。

释放一个由嵌入在对象中的锁保护的对象是一项微妙的业务，因为拥有锁并不能保证释放是正确的。问题出现在当其他线程在 `acquire` 中等待使用对象时；释放对象隐含地释放了嵌入式锁，这将导致等待的线程出现故障。一种解决方案是跟踪对象的引用数量，这样只有在最后一个引用消失时才会释放它。参见 `pipeclose` (kernel/pipe.c:59) 的示例；`pi->readopen` 和 `pi->writeopen` 跟踪管道是否有引用到它的文件描述符。

通常，人们会看到锁围绕着对一组相关项目的一系列读写；只要它们也锁定，锁就确保其他线程只能看到已完成的更新序列。那么对于更新是对单个共享变量的简单写入的情况呢？例如，`setkilled` 和 `killed` (kernel/proc.c:607) 在简单使用 `p->killed` 时加锁。如果没有锁，一个线程可能在另一个线程读取它的同时写入 `p->killed`。这是一个 竞争，C 语言规范说这种竞争会产生**未定义行为**(*undefined behavior*)，这意味着程序可能崩溃或产生错误的结果。锁可以防止竞争并避免未定义行为。

竞争可能破坏程序的一个原因是，如果没有锁或等效结构，编译器可能生成以与原始 C 代码完全不同的方式读写内存的机器代码。例如，调用 `killed` 的线程的机器代码可能将 `p->killed` 复制到寄存器并仅读取该缓存值；这意味着该线程可能永远不会看到对 `p->killed` 的任何写入。锁可以防止这种缓存。

## 类锁模式

在许多地方，xv6 以类似锁的方式使用引用计数或标志来表示对象已分配且不应被释放或重用。进程的 `p->state`  就是以这种方式工作的，`file`、`inode` 和 `buf` 结构中的引用计数也是如此。虽然在每种情况下，锁都保护着标志或引用计数，但后者防止了对象被过早释放。

文件系统使用 `struct inode`} 引用计数作为一种可以由多个进程持有的共享锁，以避免如果代码使用普通锁可能出现的死锁。例如，在 `namex`  (kernel/fs.c:652) 循环中，依次锁定每个路径名组件所命名的目录。然而，`namex` 必须在循环结束时释放每个锁，因为如果它持有多个锁，当路径名包含点（例如，`a/./b`）时，它可能会与自身死锁。它还可能与涉及目录和 `..` 的并发查找死锁。正如第 8 章所解释的，解决方案是循环将目录 inode 带到下一次迭代，引用计数递增，但不加锁。

某些数据项在不同的时间可能受到不同机制的保护，有时可能由于xv6代码的结构而被隐式地保护，而不是通过显式锁。例如，当一个物理页是空闲的时候，它受到 kmem.lock 的保护 (kernel/kalloc.c:24)。如果该页随后被分配为管道 (kernel/pipe.c:23)，它将受到另一个锁（嵌入式的`pi->lock`）的保护。如果该页重新分配给新进程的用户内存，它根本不受锁保护。相反，分配器不会将该页提供给任何其他进程（直到它被释放）的事实可以保护它免受并发访问。

新进程内存的所有权比较复杂：首先父进程在`fork`中分配并操作它，然后子进程使用它，最后（在子进程退出后）父进程再次拥有内存并将其传递给`kfree`。这里有两个教训：在数据对象的生命周期的不同点，可能会以不同的方式保护它免受并发性；保护可能采取隐式结构而不是显式锁的形式。

最后一个类似锁的例子是在调用`mycpu()` (ker- nel/proc.c:83)时需要禁用中断。禁用中断会导致调用代码相对于可能强制上下文切换的定时器中断具有原子性，从而将进程移动到其他CPU。

## 一点锁都没有

在一些地方，xv6在完全没有锁的情况下共享可变数据。其中之一是在自旋锁的实现中，尽管可以将 RISC-V 原子指令视为依赖于硬件实现的锁。另一个是`main.c`中的`started`变量 (kernel/main.c:7)，用于防止其他 CPU 运行，直到 CPU 零完成初始化 xv6；`volatile`确保编译器实际生成加载和存储指令。

Xv6 包含这样一些情况：一个 CPU 或线程写入一些数据，另一个 CPU 或线程读取数据，但没有专门的锁用于保护该数据。例如，在`fork`中，父进程写入子进程的用户内存页，子进程（可能在不同的 CPU 上的不同线程）读取这些页；没有锁显式地保护这些页。这不严格是一个锁定问题，因为子进程在父进程完成写入之后才开始执行。这是一个潜在的内存排序问题（参见第 6 章），因为没有内存屏障，没有理由期望一个 CPU 看到另一个 CPU 的写入。然而，由于父进程释放锁，子进程在启动时获取锁，`acquire`和`release`中的内存屏障确保子进程的 CPU 看到父进程的写入。

## 并行性

锁主要是为了在正确性的利益下抑制并行性。由于性能同样重要，内核设计者通常需要考虑如何使用锁来实现正确性和并行性。尽管 xv6 没有系统地设计为高性能，但仍值得考虑哪些 xv6 操作可以并行执行，哪些可能在锁上发生冲突。

xv6 中的管道是相当好的并行性示例。每个管道都有自己的锁，因此不同的进程可以在不同的 CPU 上并行地读写不同的管道。然而，对于给定的管道，写入者和读取者必须等待对方释放锁；它们不能同时读/写相同的管道。对于空管道的读取（或对满管道的写入）必须阻塞，但这并不是由于锁定方案。

上下文切换是一个更复杂的例子。两个内核线程，每个线程在自己的 CPU 上执行，可以同时调用`yield`、`sched`和`swtch`，这些调用将并行执行。线程各自持有一个锁，但它们是不同的锁，因此它们不必等待对方。然而，在`scheduler`中，两个 CPU 在搜索`RUNNABLE`状态的进程时可能会在锁上发生冲突。也就是说，xv6 在上下文切换期间可能会从多个 CPU 获得性能提升，但可能不及其最大值。

另一个例子是在不同 CPU 上的不同进程对`fork`的并发调用。这些调用可能需要等待彼此的`pid_lock`和`kmem.lock`，以及搜索`UNUSED`进程的进程表所需的每个进程锁。另一方面，两个分叉进程可以完全并行地复制用户内存页和格式化页表页。

上述每个示例中的锁定方案都在某些情况下牺牲了并行性能。在每种情况下，都可以使用更复杂的设计获得更多的并行性。是否值得取决于细节：调用相关操作的频率，持有争用锁的代码执行时间，可能同时运行冲突操作的 CPU 数量，以及代码的其他部分是否更具限制性瓶颈。很难猜测给定的锁定方案是否可能导致性能问题，或者新设计是否明显更好，因此通常需要对实际负载进行测量。