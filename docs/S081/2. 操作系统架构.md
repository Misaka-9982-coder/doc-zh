# 2. 操作系统架构

操作系统的一个关键要求是支持同时进行多个活动。例如，使用第1章中描述的系统调用接口，进程可以使用 fork 启动新进程。操作系统必须在这些进程之间共享计算机资源。例如，即使有更多的进程而不是硬件 CPU，操作系统也必须确保所有进程都有执行的机会。操作系统还必须安排各个进程之间的隔离。也就是说，如果一个进程出现错误并发生故障，则不应影响不依赖于错误流程的其他流程。然而完全隔离太过头了，因为应该允许流程有意地相互作用；管道就是一个例子。因此，操作系统必须满足三个要求：复用、隔离和交互。 

本章概述了如何组织操作系统以实现这三个要求。事实证明有很多方法可以做到这一点，但本文重点介绍围绕宏内核设计的主流设计，在许多Unix操作系统中使用该内核。 Xv6 运行在一种多核 RISC-V 微处理器上，并且它的低级功能（例如其过程实现）特定于 RISC-V. RISC-V 是 64 位 CPU，并且 xv6 是用“LP64”的 C 编写 的 ，这意味着 C 语言中 long (L) 和指针(P) 都是 64 位, 而 int 则为 32 位. 这本书假设读者已经对某种体系结构进行了一些机器级编 程，并将在涉及到时介绍 RISC-V 特定思想 。RISC-V 的一个有用参考资料 是 “The RISC -V Reader: An Open Architecture Atlas”  . 用户级 ISA 和特权架构 是官方规格说明。 

完整计算机中的 CPU 周围都由支持硬件包围 , 其中大部分以 I/O 接口形式存在 。 Xv6 写入 qemu 的 “-machine virt” 选项模拟 的 支持硬件 。 这包括 RAM、ROM 包含引导代码、与用户键盘/屏幕连接和存储磁盘等内容 。



## 抽象物理资源

当遇到操作系统时，人们可能会问的第一个问题是为什么需要它？也就是说，可以将图1.2 中的系统调用实现为库，并与应用程序链接。在这个计划中，每个应用程序甚至都可以拥有自己量身定制的库以满足其需求。应用程序可以直接与硬件资源交互，并以最佳方式使用这些资源（例如，实现高性能或可预测性）。一些嵌入式设备或实时系统的操作系统就是按照这种方式组织的。 

这种库函数的缺点在于，如果有多个应用程序运行，则必须使各个应用程序表现良好。例如，每个应用程序必须定期放弃 CPU 以便其他应用程序运行。如果所有应用之间都相互信任且没有错误，则此类协作时间共享方案可能没问题。但更典型的情况是各种不同类型和质量水平、彼此不信任并存在漏洞等因素影响下进行开发，在这种情况下通常需要比合作方案提供更强大隔离措施。 

要实现强隔离很有帮助：禁止应用直接访问敏感硬件资源，并将资源抽象成服务形式提供给用户使用。例如，在 Unix 上只通过文件系统打开、读取、写入和关闭文件来与存储交互而非直接读写磁盘；这样既为用户提供了路径名等便利功能又允许操作系统（即界面实现者）管理磁盘；即使不存在安全隐患也如此——那些想要相互配合或保持距离地进行交互处理任务的进程通常会发现文件系统比直接使用磁盘更加方便。 

同样地，在 Unix 上透明地切换硬件 CPU 进程状态并保存/恢复寄存器状态等信息，从而无需考虑时间共享问题；即使某些进程陷入死循环也不会影响整体效率。 

再举一个例子：Unix 进程使用 exec 构建内存映像而非直接与物理内存交互；由此操作系统可以决定将进程放置在何处——如果内存紧张，则甚至可能将某些过程数据存储在磁盘上；exec 还提供了用户可通过文件系统来存储可执行编译后代码镜像所需内容等优点。 

Unix 进程之间许多形式化交流均通过文件描述符完成：除了抽象出众多细节外（例如管道或文件中数据所处位置），它们还定义了简化交流方式规范标准。例如，在管道中若其中一个工具失败则核心生成结束信号传递给下一个工具处理任务。 

图1.2中显示出来得到 API 设计精心考虑到两者之间权衡关系及其对编码人员友好度和是否支持强大隔离措施两方面因素同时考虑得出结果 。 Unix 界面并非唯一抽象资源方法 ，但已被证明是一种非常有效的方法 。

## 用户模式、管理模式、系统调用

强隔离需要应用程序和操作系统之间有一个硬边界。如果应用程序出现错误，我们不希望操作系统或其他应用程序失败。相反，操作系统应该能够清理失败的应用程序并继续运行其他应用程序。为了实现强隔离，操作系统必须安排使得应用程序无法修改（甚至读取）操作系统的数据结构和指令，并且不能访问其他进程的内存。 

CPU 提供了对于强隔离的硬件支持。例如，RISC-V 有三种模式可以执行指令：机器模式、监管者模式和用户模式。在机器模式下执行的指令具有完全特权；CPU 在机器模式下启动。机器模式主要是为配置计算机而设计的。Xv6 在机器模式下执行几行代码然后切换到监管者模式。 

在监管者模式下，CPU 允许执行特权指令：例如启用和禁止中断、读写保存页表地址寄存器等等。如果处于用户态（user mode） 的应用程序尝试执行特权指令，则 CPU 不 执行此指令 ， 而是切换到监管者模式 （supervisor mode），以便监管者级别代码可以终止该应用程序，因为它做了一些不该做的事情 。第 1 章中图 1.1 说明了这个组织方式 。一个应用程序只能执行用户态指令（如加法等），称其正在运行在用户空间 (user space) 中；而运行在监管者级别 (supervisor mode) 的软件也可以执行特权指令，并称其正在运行在内核空间 (kernel space) 中 。 运行在内核空间 ( 或监管员模式 ) 的软件称作内核 (kernel)。 

想要调度内核函数 (如 xv6 中 read 系统调用)，则必须将一个进程从用户态转变成超级管理员状态 (supervisor mode); 进程不能直接调度内核函数 。 CPU 提供一条专门命名来完成此任务——将 CPU从用户态切换到超级管理员状态并通过由 kernel 规定好入口点(entry point)进入 kernel。(RISC-V提供 ecall 操作码来完成此任务）。一旦 CPU 已经切换到超级管理员状态, 内核就能验证系统调用参数(例如检查传递给系统调用的地址是否属于当前进程),决定是否允许进行请求操作(例如检查当前进程是否被允许写入文件),然后拒绝或执行请求 .重要性质是: 必须由 kernel 控制所有向超级管理员状态转移时所使用 entry point; 如果应用程序可以决定 kernel 入口点, 那么恶意应用程序就可能会跳过参数验证步骤并直接跳转至某个位置引发问题.

## 内核组织

一个关键的设计问题是操作系统的哪一部分应该在特权模式下运行。一种可能性是整个操作系统都驻留在内核中，以便所有系统调用的实现都在管理模式下运行。这种组织被称为宏内核。

在这种组织中，整个操作系统都以完全的硬件特权运行。这种组织很方便，因为操作系统设计者不必将操作系统分解成小块，以便它们可以在用户模式下运行。

决定操作系统哪些部分不需要完全的硬件特权。此外，不同部分的操作系统更容易合作。例如，操作系统可能有一个缓冲区缓存，可以由文件系统和虚拟内存系统共享。

宏内核的缺点是操作系统不同部分之间的接口通常很复杂，因此操作系统开发人员很容易犯错误。在单体内核中，一个错误是致命的，因为监管模式中的错误通常会导致内核失败。如果内核失败，计算机将停止工作，因此所有应用程序也将失败。计算机必须重新启动才能重新开始。

为了减少内核中的错误风险，操作系统设计人员可以最小化在监管模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统。这个内核组织被称为微内核。

![]( http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c2/p1.png)

图 2.1 展示了这种微内核设计。在图中，文件系统作为用户级进程运行。作为进程运行的操作系统服务被称为服务器。为了允许应用程序与文件服务器交互，内核提供了一个进程间通信机制，用于从一个用户模式进程发送消息到另一个进程。例如，如果像shell这样的应用程序想要读取或写入文件，它会发送一个消息到文件服务器并等待响应。



在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织方式使得内核相对简单，因为大部分操作系统都驻留在用户级服务器中。

在现实世界中，单体内核和微内核都很受欢迎。许多 Unix 内核都是宏内核。例如，Linux 具有单体内核，尽管某些操作系统功能作为用户级服务器运行，例如窗口系统。 Linux 为操作系统密集型应用程序提供高性能，部分原因是内核的子系统可以紧密集成。

像 Minix、L4 和 QNX 这样的操作系统以服务器为中心的微内核组织方式，在嵌入式环境中得到了广泛应用。 L4 的一个变体 seL4 足够小，已经验证了内存安全性和其他安全属性。

操作系统开发人员之间存在很多关于哪种组织方式更好的争论，没有定论。此外，这很大程度上取决于“更好”的含义：更快的性能、更小的代码大小、内核的可靠性、包括用户级服务在内的完整操作系统的可靠性等。

还有一些实际考虑可能比组织形式更重要。一些操作系统具有微内核，但出于性能原因在内核空间运行一些用户级服务。一些操作系统具有单片内核，因为它们最初就是这样的，没有太多的动力去转向纯微内核组织，因为新功能可能比重写现有操作系统以适应微内核设计更重要。

从这本书的角度来看，微内核和单片内核操作系统共享许多关键思想。它们实现系统调用，使用页表，处理中断，支持进程，使用锁进行并发控制，实现文件系统等。本书重点关注这些核心思想。

Xv6 实现为单片内核，像大多数 Unix 操作系统一样。因此，xv6 内核接口对应于操作系统接口，内核实现完整的操作系统。

xv6 并不提供很多服务，它的内核比一些微内核还要小，但从概念上讲，xv6 是单内核的。

## 代码：xv6组织

| **File**       | **Description**                                        |
| -------------- | ------------------------------------------------------ |
| bio.c          | Disk block cache for the file system.                  |
| console.c      | Connect to the user keyboard and screen.               |
| entry.S        | Very first boot instructions.                          |
| exec.c         | exec() system call.                                    |
| file.c         | File descriptor support.                               |
| fs.c           | File system.                                           |
| kalloc.c       | Physical page allocator.                               |
| kernelvec.S    | Handle traps from kernel, and timer interrupts.        |
| log.c          | File system logging and crash recovery.                |
| main.c         | Control initialization of other modules during boot.   |
| pipe.c         | Pipes.                                                 |
| plic.c         | RISC-V interrupt controller.                           |
| printf.c       | Formatted output to the console.                       |
| proc.c         | Processes and scheduling.                              |
| sleeplock.c    | Locks that yield the CPU.                              |
| spinlock.c     | Locks that don't yield the CPU.                        |
| start.c        | Early machine-mode boot code.                          |
| string.c       | C string and byte-array library.                       |
| swtch.S        | Thread switching.                                      |
| syscall.c      | Dispatch system calls to handling function.            |
| sysfile.c      | File-related system calls.                             |
| sysproc.c      | Process-related system calls.                          |
| trampoline.S   | Assembly code to switch between user and kernel.       |
| trap.c         | C code to handle and return from traps and interrupts. |
| uart.c         | Serial-port console device driver.                     |
| virtio\_disk.c | Disk device driver.                                    |
| vm.c           | Manage page tables and address spaces.                 |

xv6 内核源代码位于 kernel/子目录中。该源代码被分成多个文件，遵循大致的模块化概念；图 2.2 列出了这些文件。模块间接口在defs.h（kernel/defs.h）中定义。

## 进程概述


xv6 中的隔离单元，如其他 Unix 操作系统一样，是一个进程。进程抽象防止一个进程破坏或窥探另一个进程的内存、CPU、文件描述符等。它还防止进程破坏内核本身，以便进程无法破坏内核的隔离机制。

内核必须小心地实现进程抽象，因为有缺陷或恶意的应用程序可能会欺骗内核或硬件做一些坏事，例如规避隔离。内核用于实现进程的机制包括用户/监管模式标志、地址空间和线程的时间分片。

为了帮助强制隔离，进程抽象给程序提供了一种错觉，即它有自己的专用机器。进程为程序提供了一个看起来像是私有内存系统或地址空间的东西，其他进程无法读取或写入。进程还为程序提供了一个看起来像是自己的 CPU 来执行程序的指令。

Xv6 使用由硬件实现的页表为每个进程提供了自己的地址空间。它自己的地址空间。RISC-V 页表将虚拟地址（RISC-V 指令操作的地址）转换或映射为物理地址（CPU 芯片发送到主存储器的地址）。

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c2/p2.png)

Xv6 为每个进程维护一个单独的页表，定义该进程的地址空间。如图 2.3 所示，地址空间包括进程的用户内存，从虚拟地址零开始。指令首先出现，然后是全局变量，然后是堆栈，最后是一个“堆”区域，用于 malloc，进程可以根据需要扩展。

有许多因素限制进程地址空间的最大大小：RISC-V 上的指针宽度为 64 位；硬件仅在查找页表中的虚拟地址时使用低 39 位。因此，最大地址为 $2^{38}-1$ = 0x3fffffffff，即MAXVA  (kernel/riscv.h:363).。

在地址空间的顶部，xv6 保留了一个页面用于 `trampoline` 和一个页面映射进程的`trapframe`。Xv6 使用这两个页面来进入和退出内核；`trampoline` 页面包含用于进入和退出内核的代码，映射 `trapframe` 是必要的，以保存/恢复用户进程的状态，我们将在第4章中解释。

xv6 内核为每个进程维护许多状态，它们被收集到一个 `struct proc` 中。进程最重要的内核状态是其页表、内核堆栈和运行状态。我们将使用 `p->xxx` 的符号表示法来引用（proc）结构的元素；例如，`p->pagetable` 是指向进程页表的指针。

每个进程都有一个执行线程，简称线程，用于执行进程的指令。线程可以被暂停，稍后再恢复。为了在进程之间透明地切换，内核会暂停当前正在运行的线程，并恢复另一个进程的线程。线程的许多状态，如本地变量、函数调用返回地址等，都存储在线程的堆栈上。每个进程都有两个堆栈：用户堆栈和内核堆栈 `p->kstack`。当进程执行用户指令时，只使用其用户堆栈，内核堆栈为空。当进程进入内核进行系统调用或中断时，内核代码在进程的内核堆栈上执行；当进程在内核中时，其用户堆栈仍包含保存的数据，但不处于活跃状态。进程的线程在使用其用户堆栈和内核堆栈之间交替。内核堆栈与用户代码分开并受保护，以便内核可以执行其任务而不受用户代码的干扰。即使进程已经破坏了其用户栈，内核也可以正常执行。

进程可以通过执行 RISC-V 的 `ecall` 指令来进行系统调用。该指令提高了硬件特权级别，并将程序计数器更改为内核定义的入口点。入口点处的代码切换到内核堆栈并执行实现系统调用的内核指令。当系统调用完成时，内核切换回用户栈并通过调用 `sret` 指令返回到用户空间，该指令降低硬件特权级别并继续执行系统调用指令后的用户指令。进程的线程可以在内核中“阻塞”以等待 I/O，并在 I/O 完成后恢复到离开的位置。

`p->state` 指示进程是否已分配、准备运行、正在运行、正在等待 I/O 或正在退出。

`p->pagetable` 保存进程的页表，格式符合 RISC-V 硬件的要求。Xv6 使分页硬件在用户空间执行进程时使用该进程的 `p->pagetable`。进程的页表还作为记录分配给进程存储内存的物理页面地址的记录。

总之，进程捆绑了两个设计思想：地址空间为进程提供其自己内存的幻觉，线程为进程提供其自己 CPU 的幻觉。在 xv6 中，一个进程由一个地址空间和一个线程组成。在真正的操作系统中，一个进程可能有多个线程以利用多个 CPU。

## 代码：启动xv6，第一个进程和系统调用

为了让 xv6 更加具体化，我们将概述内核如何启动和运行第一个进程。随后的章节将详细描述出现在此概述中的机制。 

当 RISC-V 计算机启动时，它会初始化自身并运行存储在只读存储器中的引导加载程序。引导加载程序将 xv6 内核加载到内存中。然后，在机器模式下，CPU 从 `_entry`（kernel/entry.S:7）开始执行 xv6。 RISC-V 以禁用分页硬件的状态启动：虚拟地址直接映射到物理地址。 

加载程序将 xv6 内核加载到物理地址 `0x80000000` 处的内存中。之所以将内核放置在 `0x80000000` 而不是 `0x0` 处是因为地址范围 `0x0:  0x80000000` 包含 I/O 设备。 

`_entry` 处的指令设置了一个堆栈，以便使得 XV6 可以运行 C 代码。XV6 在 `start.c`（kernel/start.c:11）中声明了初始堆栈 `stack0` 的空间大小，并且 `_entry` 处代码通过把堆栈顶部 `stack0 + 4096` 的地址装载入堆栈指针寄存器 `sp` 中来进行设置, 因为 RISC-V 上的堆栈向下增长. 现在有了一个堆栈之后, `_entry` 便调用位于 `start` (kernel/start.c:21) 位置上的 C 代码. 

函数 `start` 执行一些仅在机器模式下允许的配置, 然后切换到监管者模式. 要进入监管者模式, RISC-V 提供 `mret` 指令. 这个指令最常用于从监管者模式返回先前对机器模式调用时使用. `start` 不是从这样一个调用返回, 而是设置好像已经有这样一个调用一样：它将 `mstatus` 寄存器中的先前特权模式设置为监督器，它通过将 `main` 的地址写入 `mepc` 寄存器将返回地址设置为 `main` ，通过将 0 写入页表寄存器 `satp` 来禁用监督器模式下的虚拟地址转换，并将所有中断和异常委托给监督器模式。

跳转至监管者之前, `start` 还要完成另外一项任务：对时钟芯片进行编程以产生计时器中断。 完成这些杂务之后, start 通过调用 `mret` "返回" 到监管者模式 . 这会导致程序计数器改变为 `main` (kernel/main.c:11). 

`main` (kernel/main.c:11) 初始化多个设备和子系统之后,通过调用 `userinit` (kernel/proc.c :233) 创建第一个进程. 

第一个进程执行由 RISC-V 汇编语言编写的小型程序，并使 xv6 中第一个系统调用 `initcode.S` (user/initcode.S :3) 将 `exec` 系统调用号 `SYS_EXEC` (kernel/syscall.h :8 ) 加载到 `a7` 寄存器中 ，然后使用 `ecall` 重新进入 内核. 

操作系统使用 `a7` 寄存器中的数字在 `syscall` ( kernel / syscall.c ：132 ) 中调用所需的系统调试 。 系统调试表 （ kernel / syscall.c ：107） 将 `SYS_EXEC` 映射到 `sys_exec` ， 内核调用它。正如我们在第1章中看到的，`exec` 用新程序（本例中为 /init）替换当前进程的内存和寄存器。

当操作系统内核完成 `exec` 后，则回归用户空间，在 `/init` 进程上执行 `init` ( user/init.c :15 )，如果需要则创建新控制台设备文件，并打开其作为文件描述符 0、1 和 2 。然后，在控制台上启动 shell 。整个系统已经准备好了！

## 安全模型

你可能会想知道操作系统如何处理有缺陷或恶意代码。因为处理恶意行为比处理意外错误更加困难，所以合理地将这个主题视为与安全有关。以下是操作系统设计中典型安全假设和目标的高层视图。

操作系统必须假设进程的用户级代码会尽其所能破坏内核或其他进程。用户代码可能会尝试在其允许的地址空间之外引用指针；它可能会...尝试执行任何RISC-V指令，即使这些指令不是为用户代码而设计的；它可能尝试读写任何RISC-V控制寄存器；它可能尝试直接访问设备硬件；并且它可能会传递巧妙的值给系统调用，试图欺骗内核崩溃或做出愚蠢的行为。内核的目标是限制每个用户进程，使其只能读/写/执行自己的用户内存，使用 32 个通用 RISC-V 寄存器，并以系统调用允许的方式影响内核和其他进程。内核必须防止任何其他操作。这通常是内核设计中的绝对要求。

内核自身代码的期望是完全不同的。内核代码假定是由善意和谨慎的程序员编写的。内核代码应该是无错误的，当然不包含任何恶意代码。这种假设影响了我们分析内核代码的方式。例如，有许多内部内核函数，例如自旋。

如果内核代码错误地使用它们，锁可能会导致严重问题。在检查任何特定的内核代码时，我们希望确信它的行为是正确的。然而，我们假设内核代码总体上是正确的，并遵循有关使用内核自身函数和数据结构的所有规则。在硬件层面上，RISC-V CPU、RAM、磁盘等被认为是按照文档中所述的方式运行的，没有硬件缺陷。

当然，在现实生活中事情并不那么简单。很难防止聪明的用户代码通过消耗内核保护资源（磁盘空间、CPU时间、进程表槽等）使系统无法使用或导致它崩溃。编写无缺陷的代码或设计无缺陷的硬件通常是不可能的；如果恶意用户代码的编写者意识到内核或硬件缺陷，他们将利用它们。即使在成熟的、广泛使用的内核中，例如 Linux，人们也会持续不断地发现新的漏洞。

在内核中设计防护措施以防止出现漏洞是值得的：断言、类型检查、堆栈保护页等。最后，用户和内核代码之间的区别有时会模糊：一些特权用户级进程可能提供必要的服务并有效地成为操作系统的一部分，在一些操作系统中，特权用户代码可以像 Linux 的可加载内核模块一样插入新代码到内核中。

## 现实世界

大多数操作系统都采用了进程概念，而且大多数进程看起来与 xv6 的相似。然而，现代操作系统支持在一个进程内支持多个线程，以允许单个进程利用多个CPU。在一个进程中支持多个线程涉及到很多机制，在 xv6 中并没有这些机制，包括可能的接口更改（例如 Linux 的 clone，fork 的一种变体），以控制线程共享哪些方面的进程。
