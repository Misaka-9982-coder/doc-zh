# 8. 文件系统

文件系统的目的是组织和存储数据。文件系统通常支持在用户和应用程序之间共享数据，以及 **持久性**，以便在重新启动后数据仍然可用。

xv6 文件系统提供类 Unix 的文件、目录和路径名（参见第 1 章），并将其数据存储在虚拟磁盘上以实现持久性。文件系统解决了以下几个挑战：

*   文件系统需要磁盘上的数据结构来表示命名目录和文件的树，记录保存每个文件内容的块的身份，以及记录磁盘上哪些区域是空闲的。
*   文件系统必须支持**崩溃恢复** (*crash recovery*)。也就是说，如果发生崩溃（例如，电源故障），文件系统在重新启动后仍然必须正常工作。风险在于崩溃可能会中断一系列更新并使磁盘上的数据结构不一致（例如，一个既用于文件又标记为空闲的块）。
*   不同的进程可能同时在文件系统上操作，因此文件系统代码必须协同工作以维护不变量。
*   访问磁盘比访问内存慢几个数量级，因此文件系统必须维护一个热门块的内存缓存。

本章其余部分将解释 xv6 是如何应对这些挑战的。

## 概述

xv6 文件系统的实现分为七层，如图 8.1 所示。磁盘层在虚拟硬盘上读写块。缓冲区缓存层缓存磁盘块并同步对它们的访问，确保一次只有一个内核进程可以修改存储在任何特定块中的数据。日志层允许更高层将对几个块的更新包装在一个 **事务** (*transaction*)中，并确保在崩溃时这些块以原子方式更新（即，全部更新或全部不更新）。inode 层提供单个文件，每个文件表示为一个具有唯一编号的 **inode** 和一些保存文件数据的块。目录层将每个目录实现为一种特殊类型的 inode，其内容是一系列目录条目，每个目录条目包含文件的名称和 i-number。路径名层提供类似于 `/usr/rtm/xv6/fs.c` 的分层路径名，并使用递归查找对它们进行解析。文件描述符层使用文件系统接口抽象许多 Unix 资源（例如，管道、设备、文件等），简化了应用程序编写者的工作。

| 文件描述符（File descriptor）  |
| ------------------------------ |
| 路径名（Pathname）             |
| 目录（Directory）              |
| 索引结点（Inode）              |
| 日志（Logging）                |
| 缓冲区高速缓存（Buffer cache） |
| 磁盘（Disk）                   |

 图8.1：xv6 文件系统的层次结构 

传统磁盘硬件将磁盘上的数据呈现为编号顺序的 512 字节**块**(*blocks*)（也称为**扇区**(*sectors*)）：扇区 0 是前 512 字节，扇区 1 是接下来的字节，依此类推。操作系统用于其文件系统的块大小可能与磁盘使用的扇区大小不同，但通常块大小是扇区大小的倍数。xv6 将读取到内存中的块的副本保存在类型为 `struct buf` (kernel/buf.h:1)的对象中。此结构中存储的数据有时与磁盘不同步：可能尚未从磁盘读入（磁盘正在处理但尚未返回扇区内容），或者可能已由软件更新但尚未写入磁盘。

文件系统必须计划在磁盘上存储 inode 和内容块的位置。为此，xv6 将磁盘划分为几个部分，如图8.2所示。文件系统不使用块 0（它保存了引导扇区）。块 1 称为**超级块**(*superblock*)；它包含有关文件系统的元数据（文件系统大小（以块为单位）、数据块数量、inode 数量以及日志中的块数量）。从 2 开始的块保存日志。日志之后是 inode，每个块有多个 inode。inode 后面是位图块，用于追踪正在使用的数据块。剩下的块是数据块；每个块要么在位图块中标记为自由，要么保存文件或目录的内容。一个单独的程序，称为 `mkfs`，填充超级块，它构建了一个初始文件系统。

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c8/p1.png)

本章的其余部分将讨论每个层次，从缓冲区缓存开始。注意在较低层选择的抽象如何简化了较高层的设计。

## 缓冲区缓存层

缓冲区缓存有两个任务：

- 同步对磁盘块的访问，以确保内存中只有一个块的副本，并且一次只有一个内核线程使用该副本；
- 缓存常用块，以便不需要从慢速磁盘重新读取它们。代码位于 `bio.c`。

缓冲区缓存导出的主要接口包括 `bread` 和 `bwrite`；前者获取一个包含可在内存中读取或修改的块副本的缓冲区，后者将修改后的缓冲区写入磁盘上的相应块。内核线程在完成缓冲区操作时必须通过调用 `brelse` 来释放它。缓冲区缓存使用每个缓冲区的睡眠锁来确保一次只有一个线程使用每个缓冲区（因此每个磁盘块）；`bread` 返回一个锁定的缓冲区，`brelse` 释放锁。

让我们回到缓冲区缓存。缓冲区缓存具有固定数量的缓冲区来保存磁盘块，这意味着如果文件系统请求一个尚未在缓存中的块，缓冲区缓存必须回收当前保存其他块的缓冲区。缓冲区缓存会将最近最少使用的缓冲区回收用于新块。这个假设是最近最少使用的缓冲区是最不可能再次使用的。

## 代码：缓冲区缓存

缓冲区缓存是一个双向链表，由缓冲区组成。函数 `binit`，由 `main` 调用  (kernel/main.c:27), 使用静态数组 `buf` 中的 `NBUF` 缓冲区初始化链表 (kernel/bio.c:43-52)。对缓冲区缓存的所有其他访问都是通过 `bcache.head` 引用链表，而不是 `buf` 数组。

一个缓冲区有两个与之相关的状态字段。字段 `valid` 表示缓冲区包含一个块的副本。字段 `disk` 表示缓冲区内容已交给磁盘，磁盘可能会更改缓冲区（例如，将磁盘中的数据写入 `data`）。

`bread` (kernel/bio.c:93)  调用 `bget` 来获取给定扇区的缓冲区 (kernel/bio.c:97) 。如果需要从磁盘读取缓冲区，`bread` 在返回缓冲区之前调用 `virtio_disk_rw` 来执行该操作。

`bget` (kernel/bio.c:59)  扫描缓冲区列表，寻找具有给定设备和扇区号的缓冲区(kernel/bio.c:65-73). 如果有这样的缓冲区，`bget` 获取缓冲区的睡眠锁。然后 `bget` 返回锁定的缓冲区。

如果没有给定扇区的缓存缓冲区，`bget` 必须创建一个，可能会重用保存不同扇区的缓冲区。它第二次扫描缓冲区列表，寻找不在使用中的缓冲区（`b->refcnt = 0`）；可以使用任何这样的缓冲区。`bget` 编辑缓冲区元数据以记录新的设备和扇区号，并获取其睡眠锁。请注意，赋值 `b->valid = 0` 确保 `bread` 将从磁盘读取块数据，而不是错误地使用缓冲区的先前内容。

确保每个磁盘扇区最多只有一个缓存缓冲区非常重要，以确保读取器看到写入，并且因为文件系统使用缓冲区上的锁进行同步。`bget` 通过持有 `bache.lock` 从第一个循环检查块是否缓存到第二个循环声明块现在已缓存（通过设置 `dev`、`blockno` 和 `refcnt`）来确保此不变式。这使得检查块的存在和（如果不存在）指定一个缓冲区来保存该块变为原子操作。

对于 `bget` 在 `bcache.lock` 临界区之外获取缓冲区的睡眠锁是安全的，因为非零的 `b->refcnt` 阻止了缓冲区被用于不同的磁盘块。睡眠锁保护对块的缓冲内容的读取和写入，而 `bcache.lock` 保护关于哪些块被缓存的信息。

如果所有缓冲区都忙碌，那么太多的进程正在同时执行文件系统调用；`bget` 会发生恐慌。更优雅的响应可能是睡眠，直到一个缓冲区变为空闲，尽管这样可能会出现死锁。

一旦 `bread` 从磁盘读取（如果需要）并将缓冲区返回给调用者，调用者就可以独占地使用缓冲区并读取或写入数据字节。如果调用者确实修改了缓冲区，它必须在释放缓冲区之前调用 `bwrite` 将更改的数据写入磁盘。`bwrite` (kernel/bio.c:107) 调用 `virtio_disk_rw` 与磁盘硬件进行通信。

当调用者完成缓冲区操作时，必须调用 `brelse` 释放它。（名称 `brelse`，即缩短的 b-release，虽然晦涩难懂，但值得学习：它起源于 Unix，并在 BSD、Linux 和 Solaris 中也有使用。）`brelse` (kernel/bio.c:117) 释放了睡眠锁，并将缓冲区移动到链接列表的前部  (kernel/bio.c:128-133)。移动缓冲区会使列表按缓冲区使用的最近程度排序（即释放的缓冲区）：列表中的第一个缓冲区是最近使用的，最后一个是最近最少使用的。 `bget` 中的两个循环利用了这一点：在最坏情况下，扫描现有缓冲区的过程必须处理整个列表，但是首先检查最近使用的缓冲区（从 `bcache.head` 开始并跟踪 `next` 指针）将在引用局部性较好时减少扫描时间。扫描选择一个缓冲区来复用，通过向后扫描（跟随 `prev` 指针）选择最近最少使用的缓冲区。

## 日志层

文件系统设计中最有趣的问题之一是崩溃恢复。这个问题的出现是因为许多文件系统操作涉及对磁盘的多次写入，而在一部分写入之后发生崩溃可能会导致磁盘上的文件系统处于不一致状态。例如，假设在文件截断过程中发生崩溃（将文件长度设置为零并释放其内容块）。根据磁盘写入的顺序，崩溃可能使 inode 保留对标记为空闲的内容块的引用，或者可能使分配的但未引用的内容块。

后者相对无害，但是引用已释放块的 inode 可能在重新启动后导致严重问题。重新启动后，内核可能会将该块分配给另一个文件，现在我们有两个不同的文件无意中指向相同的块。如果 xv6 支持多用户，这种情况可能是一个安全问题，因为旧文件的所有者将能够在新文件中读取和写入块，而新文件属于另一个用户。

Xv6 通过简单的日志形式解决了文件系统操作过程中崩溃的问题。Xv6 系统调用不直接写入磁盘上的文件系统数据结构。相反，它将要进行的所有磁盘写入的描述放在磁盘上的一个 **日志** 中。一旦系统调用将所有写入都记录在日志中，它将在磁盘上写入一个特殊的 **提交** 记录，表示日志包含完整操作。此时，系统调用将写入复制到磁盘文件系统数据结构中。在那些写入完成后，系统调用会擦除磁盘上的日志。

如果系统崩溃并重新启动，文件系统代码会在运行任何进程之前按照以下方式从崩溃中恢复。如果日志被标记为包含完整操作，则恢复代码将写入复制到磁盘文件系统中的相应位置。如果日志没有被标记为包含完整操作，恢复代码将忽略日志。恢复代码通过擦除日志来完成操作。

为什么 xv6 的日志解决了文件系统操作期间崩溃的问题？如果崩溃发生在操作提交之前，那么磁盘上的日志将不会被标记为完成，恢复代码将忽略它，磁盘的状态将如同操作未开始。如果崩溃发生在操作提交之后，那么恢复将重放操作的所有写入，如果操作已开始将它们写入磁盘数据结构。在任一情况下，日志使操作相对于崩溃具有原子性：恢复后，操作的所有写入要么都出现在磁盘上，要么都不出现。

## 日志设计

日志位于超级块中指定的固定位置。它包括一个头块，后面跟着一系列更新的块副本（称为“已记录块”）。头块包含一个扇区编号数组，每个已记录块一个，以及已记录块的计数。磁盘上头块中的计数值要么为零，表示日志中没有事务，要么为非零，表示日志中包含一个已提交的完整事务，包含指定数量的已记录块。在事务提交时，Xv6会写入头块，但在此之前不会写入，提交已记录块到文件系统后，将计数设置为零。因此，在事务进行中途发生崩溃会导致日志头块中的计数为零；提交后发生崩溃会导致非零计数。

每个系统调用的代码都指示了必须与崩溃具有原子性的一系列写操作的开始和结束。为了允许不同进程并发执行文件系统操作，日志系统可以将多个系统调用的写操作累积到一个事务中。因此，单个提交可能涉及多个完整系统调用的写操作。为了避免在事务中拆分系统调用，日志系统仅在没有文件系统系统调用正在进行时进行提交。

将多个事务一起提交的想法称为**组提交**。组提交减少了磁盘操作的数量，因为它将提交的固定成本分摊在多个操作上。组提交还将更多的并发写操作同时交给磁盘系统，可能允许磁盘在单个磁盘旋转过程中全部写入。Xv6 的 virtio 驱动程序不支持这种**批处理**，但 xv6 的文件系统设计允许它。

Xv6 在磁盘上为日志分配固定大小的空间。事务中系统调用写入的块总数必须适应该空间。这有两个后果。首先，不能允许单个系统调用写入的不同块数超过日志中的空间。对于大多数系统调用，这不是问题，但有两个系统调用可能会写入很多块：`write` 和 `unlink`。大文件写入可能会写入许多数据块和许多位图块以及一个 inode 块；取消链接大文件可能会写入许多位图块和一个 inode。Xv6 的写入系统调用将大型写入分解为多个适应日志的较小写入，而 `unlink` 不会导致问题，因为实际上 xv6 文件系统只使用一个位图块。另一个后果是，日志系统不能允许系统调用开始，除非确保系统调用的写入将适应日志中剩余的空间。

## 代码：日志

系统调用中典型的日志使用方式如下：

  ```c
begin_op();
...
bp = bread(...);
bp->data[...] = ...;
log_write(bp);
...
end_op();
  ```

`begin_op`  (kernel/log.c:127) 等待日志系统当前没有在提交，并且有足够的未预留的日志空间来存储此调用的写入。`log.outstanding` 计算预留日志空间的系统调用次数；总预留空间是 `log.outstanding` 乘以 `MAXOPBLOCKS`。增加 `log.outstanding` 既预留了空间，也防止在此系统调用期间发生提交。代码保守地假设每个系统调用可能最多写入 `MAXOPBLOCKS` 个不同的块。

`log_write`  (kernel/log.c:215) 充当 `bwrite` 的代理。它将块的扇区号记录在内存中，在磁盘上的日志中为其预留一个槽位，并在块缓存中固定缓冲区，以防止块缓存将其逐出。该块必须在提交之前一直保留在缓存中：直到那时，缓存的副本才是修改的唯一记录；在提交之后，它不能写入磁盘上的位置；并且同一事务中的其他读取必须看到修改。`log_write` 注意到一个块在单个事务期间被多次写入，并在日志中为该块分配相同的槽位。这种优化通常称为 **吸收**。例如，包含多个文件的 inode 的磁盘块在一个事务中被写入多次是很常见的。通过将多个磁盘写入吸收为一个，文件系统可以节省日志空间，并获得更好的性能，因为只需将磁盘块的一个副本写入磁盘。

`end_op`  (kernel/log.c:147)  首先减少未完成系统调用的计数。如果计数现在为零，它通过调用 `commit()` 提交当前事务。此过程分为四个阶段。`write_log()`  (kernel/log.c:179)  将事务中修改的每个块从缓冲区缓存复制到磁盘上的日志槽位。`write_head()`  (kernel/log.c:103) 将头块写入磁盘：这是提交点，崩溃后的写入将导致从日志中恢复事务的写入。`install_trans`   (kernel/log.c:69)   从日志中读取每个块并将其写入文件系统的适当位置。最后，`end_op` 用零计数写入日志头；这必须在下一个事务开始写入已记录块之前发生，以便崩溃不会导致恢复将一个事务的头与后续事务的已记录块一起使用。

`recover_from_log`  (kernel/log.c:117)  是从 `initlog` (kernel/fs.c:42)  调用的，该函数在第一个用户进程运行之前的引导过程中从 `fsinit`  (kernel/proc.c:42). 调用  (kernel/proc.c:527).。它读取日志头，并模拟 `end\_op` 的操作，如果头指示日志包含已提交事务。

日志的一个示例用法出现在 `filewrite`  (kernel/proc.c:135).。事务如下所示：

```c
begin_op();
ilock(f->ip);
r = writei(f->ip, ...);
iunlock(f->ip);
end_op();
```



此代码被包装在一个循环中，该循环将大量写入分解为一次仅有几个扇区的单个事务，以避免溢出日志。调用 `writei` 将许多块作为此事务的一部分写入：文件的 inode，一个或多个位图块以及一些数据块。

## 代码：块分配器

文件和目录内容存储在磁盘块中，必须从一个空闲池中分配。Xv6 的块分配器在磁盘上维护一个空闲位图，每个块有一个位。零位表示相应的块是空闲的；一个位表示它正在使用。程序 `mkfs` 设置与引导扇区、超级块、日志块、inode 块和位图块相对应的位。

块分配器提供两个功能：`balloc` 分配一个新的磁盘块，`bfree` 释放一个块。 `balloc` 在  (kernel/fs.c:72)  的循环考虑每个块，从块 0 开始到 `sb.size`，文件系统中的块数。它寻找一个位图位为零的块，表示它是空闲的。如果 `balloc` 找到这样一个块，它将更新位图并返回该块。为了提高效率，循环分为两个部分。外部循环读取每个位图块的位。内部循环检查单个位图块中的所有 Bits-Per-Block（`BPB`）位。如果两个进程尝试同时分配一个块，可能会发生竞争，但由于缓冲区缓存一次只允许一个进程使用任意一个位图块，因此可以防止这种情况发生。

`bfree` (kernel/fs.c:92)  找到正确的位图块并清除正确的位。同样，由 `bread` 和 `brelse` 隐含的独占使用避免了需要显式锁定。

与本章后面描述的许多代码一样，`balloc` 和 `bfree` 必须在事务内部调用。

## Inode 层

术语 **inode** 可以具有两个相关的含义。它可能指的是包含文件大小和数据块号列表的磁盘数据结构。或者 “inode” 可能指的是内存中的 inode，其中包含磁盘 inode 的副本以及内核内部需要的额外信息。

磁盘 inode 被紧凑地放入一个称为 inode 块的连续磁盘区域。每个 inode 的大小都相同，所以给定一个数字 n，很容易在磁盘上找到第 n 个 inode。实际上，这个数字 n（称为 inode 号或 i-number）就是 inode 在实现中的标识方式。

磁盘 inode 由 `struct dinode`  (kernel/fs.h:32) 定义。 `type` 字段区分文件、目录和特殊文件（设备）。类型为零表示磁盘上的 inode 是空闲的。 `nlink` 字段计算引用此 inode 的目录条目数，以便识别何时应该释放磁盘上的 inode 和其数据块。 `size` 字段记录文件内容的字节数。 `addrs` 数组记录存储文件内容的磁盘块的块号。

内核将一组活动 inode 保存在内存中的一个名为 `itable` 的表中； `struct inode` (kernel/file.h:17)  是磁盘上 `struct dinode` 的内存副本。内核只有在指向该 inode 的 C 指针存在时才在内存中存储一个 inode。 `ref` 字段计算指向内存 inode 的 C 指针的数量，如果引用计数降至零，内核将从内存中丢弃 inode。 `iget` 和 `iput` 函数获取和释放指向 inode 的指针，修改引用计数。指向 inode 的指针可以来自文件描述符、当前工作目录和诸如 `exec` 之类的瞬态内核代码。

xv6 的 inode 代码中有四个锁或类似锁的机制。 `itable.lock` 保护的不变量是 inode 在 inode 表中最多出现一次，以及内存中 inode 的 `ref` 字段计算指向 inode 的内存指针的数量。每个内存中的 inode 都有一个包含睡眠锁的 `lock` 字段，该字段确保对 inode 的字段（如文件长度）以及对 inode 的文件或目录内容块的独占访问。inode 的 `ref`（如果大于零）会导致系统将 inode 保留在表中，并且不为其他 inode 重用表条目。最后，每个 inode 包含一个 `nlink` 字段（在磁盘上，并在内存中复制，如果在内存中），该字段计算指向文件的目录条目数；如果链接计数大于零，xv6 不会释放 inode。

由 `iget()` 返回的 `struct inode` 指针在相应的 `iput()` 调用之前保证有效；inode 不会被删除，指针引用的内存不会为其他 inode 重用。 `iget()` 为 inode 提供非独占访问，因此可以有许多指向同一个 inode 的指针。文件系统代码的许多部分依赖于 `iget()` 的行为，既用于长期引用 inode（作为打开的文件和当前目录），也用于防止在处理多个 inode 的代码中避免死锁（例如路径名查找）。

`iget` 返回的 `struct` `inode` 可能没有任何有用的内容。为了确保它包含磁盘上的 inode 副本，代码必须调用 `ilock`。这将锁定 inode（以便其他进程不能 `ilock` 它）并从磁盘读取 inode（如果尚未读取）。 `iunlock` 释放对 inode 的锁定。将 inode 指针的获取与锁定分开有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以保持指向由 `iget` 返回的 inode 的 C 指针，但一次只能有一个进程锁定 inode。

inode 表仅存储内核代码或数据结构持有 C 指针的 inode。它的主要任务是同步多个进程的访问。inode 表还会缓存经常使用的 inode，但缓存是次要的；如果 inode 经常使用，缓冲区缓存可能会将其保留在内存中。修改内存中 inode 的代码使用 `iupdate

## 代码：Inodes

为了分配一个新的 inode（例如，创建一个文件），xv6 调用 `ialloc` (kernel/fs.c:199)。`ialloc` 类似于 `balloc`：它一次一个块地遍历磁盘上的 inode 结构，寻找标记为空闲的 inode。当找到一个时，它通过将新的 `type` 写入磁盘来声明 inode，然后通过尾调用 `iget`(kernel/fs.c:213)返回 inode 表中的一个条目。`ialloc` 的正确操作取决于一次只有一个进程可以持有对 `bp` 的引用：`ialloc` 可以确保其他进程不会同时看到 inode 是可用的并尝试声明它。

`iget` (kernel/fs.c:247)在 inode 表中查找具有所需设备和 inode 编号的活动条目（`ip->ref > 0`）。如果找到了一个，它将返回对该 inode 的新引用(kernel/fs.c:256-260)。在 `iget` 扫描过程中，它记录第一个空槽的位置(kernel/fs.c:256-260)，如果需要分配表条目，将使用该位置。

在读取或写入其元数据或内容之前，代码必须使用 `ilock` 锁定 inode。`ilock`(kernel/fs.c:293) 使用睡眠锁来达到这个目的。一旦 `ilock` 获得对 inode 的独占访问权限，如果需要，它会从磁盘（更可能是缓冲区缓存）中读取 inode。函数 `iunlock`(kernel/fs.c:321) 释放睡眠锁，这可能会导致任何正在睡眠的进程被唤醒。

`iput`(kernel/fs.c:337) 通过递减引用计数(kernel/fs.c:360) 释放对 inode 的 C 指针。如果这是最后一个引用，inode 在 inode 表中的槽现在变为空闲，可以为不同的 inode 重用。

如果 `iput` 发现没有 C 指针引用到 inode，并且 inode 没有指向它的链接（在目录中不存在），那么必须释放 inode 及其数据块。`iput` 调用 `itrunc` 将文件截断为 0 字节，释放数据块；将 inode 类型设置为 0（未分配）；并将 inode 写入磁盘(kernel/fs.c:342) 。

在 `iput` 中释放 inode 的情况下，锁定协议值得仔细研究。一种危险是，并发线程可能在 `ilock` 中等待使用该 inode（例如，读取文件或列出目录），并且不准备发现 inode 不再分配。这种情况不会发生，因为如果 inode 没有指向它的链接，并且 `ip->ref` 是 1，系统调用无法获得指向内存中 inode 的指针。这个引用是调用 `iput` 的线程拥有的引用。确实，`iput` 在其 `itable.lock` 临界区之外检查引用计数是否为 1，但在那一点上，链接计数已知为零，因此没有线程会尝试获取新的引用。另一个主要危险是，对 `ialloc` 的并发调用可能选择与 `iput` 释放的相同 inode。这只能在 `iupdate` 将磁盘写入以使 inode 具有类型零之后发生。这种竞争是良性的；分配线程会在读取或写入 inode 之前等待获取 inode 的睡眠锁，此时 `iput` 已经完成。

`iput()` 可以写入磁盘。这意味着任何使用文件系统的系统调用都可能写入磁盘，因为系统调用可能是最后一个引用文件的调用。即使像 `read()` 这样看似只读的调用，也可能最终调用 `iput()`。反过来，这意味着即使是只读的系统调用，如果它们使用文件系统，也必须在事务中进行包装。

`iput()` 与崩溃之间存在一个具有挑战性的相互作用。当文件的链接计数降为零时，`iput()` 不会立即截断文件，因为某个进程可能仍然在内存中持有对 inode 的引用：进程可能仍在读写文件，因为它已成功打开它。但是，如果在最后一个进程关闭文件描述符之前发生崩溃，那么文件将在磁盘上被标记为已分配，但没有目录项指向它。

文件系统以两种方式之一处理此情况。简单的解决方案是，在恢复后，在重启后，文件系统扫描整个文件系统以查找标记为已分配的文件，但没有目录项指向它们。如果存在这样的文件，那么可以释放这些文件。

第二种解决方案不需要扫描文件系统。在此解决方案中，文件系统在磁盘上记录（例如，在超级块中）链接计数降为零但引用计数不为零的文件的 inode inumber。如果文件系统在引用计数达到 0 时删除文件，则通过从列表中删除该 inode 来更新磁盘上的列表。在恢复时，文件系统释放列表中的任何文件。

Xv6 没有实现这两种解决方案，这意味着 inode 可能在磁盘上被标记为已分配，即使它们不再使用。这意味着随着时间的推移，xv6 有可能耗尽磁盘空间。

## 代码：Inode 内容

磁盘上的 inode 结构，`struct dinode`，包含一个大小和一个块号数组(见图8.3)。inode 数据位于 `dinode` 的 `addrs` 数组中列出的块中。数据的前 `NDIRECT` 个块在数组的前 `NDIRECT` 个条目中列出；这些块称为**直接块**。下一个 `NINDIRECT` 个数据块不在 inode 中，而是在一个称为**间接块**的数据块中。`addrs` 数组的最后一个条目给出了间接块的地址。因此，文件的前 12 kB（`NDIRECT` x `BSIZE`）字节可以从 inode 中列出的块中加载，而接下来的 256 kB（`NINDIRECT` x `BSIZE`）字节只能在查询间接块之后加载。这是一个很好的磁盘表示，但对客户端来说是一个复杂的表示。函数 `bmap` 管理表示，以便高级例程（如我们将很快看到的 `readi` 和 `writei`）不需要处理这种复杂性。`bmap` 返回 inode `ip` 的第 `bn` 个数据块的磁盘块号。如果 `ip` 还没有这样的块，`bmap` 会分配一个。

函数 `bmap`(kernel/fs.c:383) 首先处理简单情况：前 `NDIRECT` 个块在 inode 本身中列出(kernel/fs.c:388-396) 。接下来的 `NINDIRECT` 个块在 `ip->addrs[NDIRECT]` 的间接块中列出。`bmap`读取间接块 (kernel/fs.c:407) ，然后从块内正确的位置读取块号 (kernel/fs.c:408) 。如果块号超过`NDIRECT+NINDIRECT`，`bmap` 将会触发panic；`writei` 包含防止这种情况发生的检查(kernel/fs.c:513) 。

`bmap` 根据需要分配块。`ip->addrs[]` 或间接条目为零表示未分配块。当 `bmap` 遇到零时，它用按需分配的新块的编号替换它们 (kernel/fs.c:389-390) (kernel/fs.c:401-402).。

`itrunc` 释放文件的块，将 inode 的大小重置为零。`itrunc` (kernel/fs.c:426) 首先释放直接块 (kernel/fs.c:432-437)，然后释放间接块中列出的块 (kernel/fs.c:442- 445)，最后释放间接块本身 (kernel/fs.c:447-448)。

`bmap` 使得 `readi` 和 `writei` 更容易访问 inode 的数据。`readi` (kernel/fs.c:472)首先确保偏移量和计数不超出文件的末尾。从文件末尾开始的读取将返回错误 (kernel/fs.c:477-478)，而从文件末尾开始或跨越文件末尾的读取将返回少于请求的字节数 (kernel/fs.c:479-480)。主循环处理文件的每个块，将数据从缓冲区复制到 `dst`  (kernel/fs.c:482-494)中。`writei` (kernel/fs.c:506) 与 `readi` 相同，但有三个例外：从文件末尾开始或跨越文件末尾的写操作会增加文件的大小，直到最大文件大小 (kernel/fs.c:513-514)；循环将数据复制到缓冲区而不是从缓冲区中复制 (kernel/fs.c:36)；如果写操作已经扩展了文件，`writei` 必须更新其大小。

函数 `stati`  (kernel/fs.c:458) 将 inode 元数据复制到 `stat` 结构中，该结构通过 `stat` 系统调用暴露给用户程序。

## 代码：目录层

目录在内部的实现与文件非常相似。它的 inode 类型为 `T_DIR`，其数据是一系列目录条目。每个条目都是一个 `struct dirent`(kernel/fs.h:56)，其中包含一个名称和一个 inode 编号。名称最多为 `DIRSIZ`（14）个字符；如果短一些，则以空（0）字节结尾。inode 编号为零的目录条目是空闲的。

函数 `dirlookup` (kernel/fs.c:552)在目录中搜索具有给定名称的条目。如果找到一个，它将返回一个指向相应 inode 的指针（未锁定），并将 `*poff` 设置为目录内条目的字节偏移量，以防调用者希望编辑它。如果 `dirlookup` 找到一个具有正确名称的条目，它会更新 `*poff` 并返回通过 `iget` 获得的未锁定的 inode。`dirlookup` 是 `iget` 返回未锁定的 inode 的原因。调用者已经锁定了 `dp`，因此如果查找是针对 `.`（当前目录的别名），在返回之前尝试锁定 inode 将尝试重新锁定 `dp` 并死锁。（涉及多个进程和 `..`（父目录的别名）的更复杂的死锁情景；`.` 不是唯一的问题。）调用者可以解锁 `dp` 然后锁定 `ip`，确保一次只持有一个锁。

函数 `dirlink` (kernel/fs.c:580) 将具有给定名称和 inode 编号的新目录条目写入目录 `dp` 中。如果名称已经存在，`dirlink` 返回一个错误 (kernel/fs.c:586- 590)。主循环读取目录条目，查找未分配的条目。当找到一个时，它提前停止循环 (kernel/fs.c:563-564),，并将 `off` 设置为可用条目的偏移量。否则，循环以 `off` 设置为 `dp->size` 结束。无论哪种方式，`dirlink` 然后通过在偏移量 `off` 处写入来向目录中添加新条目。

## 代码：路径名

路径名查找涉及对 `dirlookup` 的一系列调用，每个路径组件调用一次。`namei` (kernel/fs.c:687) 计算 `path` 并返回相应的 `inode`。函数 `nameiparent` 是一个变体：它在最后一个元素之前停止，返回父目录的 inode 并将最后一个元素复制到 `name` 中。两者都调用通用函数 `namex` 来完成实际工作。

`namex`(kernel/fs.c:652) 首先决定路径评估从哪里开始。如果路径以斜杠开头，评估将从根目录开始；否则，从当前目录开始(kernel/fs.c:656-659).。然后它使用 `skipelem` 逐个考虑路径中的每个元素(kernel/fs.c:661).。循环的每次迭代都必须在当前 inode `ip` 中查找 `name`。迭代从锁定 `ip` 开始，并检查它是否是一个目录。如果不是，查找失败(kernel/fs.c:662-666).。锁定 `ip` 是必要的，不是因为 `ip->type` 会突然改变（实际上不会），而是因为在 `ilock` 运行之前，`ip->type` 并不能保证已经从磁盘加载。如果调用是 `nameiparent` 并且这是最后一个路径元素，则根据 `nameiparent` 的定义，循环提前停止；最后一个路径元素已经复制到 `name` 中，因此 `namex` 只需返回未锁定的 `ip` (kernel/fs.c:667-671)。最后，循环使用 `dirlookup` 查找路径元素，并通过设置 `ip = next` 为下一次迭代做准备(kernel/fs.c:672-677)。当循环用完路径元素时，它返回 `ip`。

程序 `namex` 可能需要很长时间才能完成：它可能涉及对路径名中遍历的目录的 i-node 和目录块进行几次磁盘操作（如果它们不在缓冲区缓存中）。Xv6 的设计非常精细，以便在一个内核线程调用 `namex` 并因磁盘 I/O 而阻塞时，另一个内核线程可以同时查找不同的路径名。`namex` 分别锁定路径中的每个目录，以便不同目录中的查找可以并行进行。

这种并发引入了一些挑战。例如，当一个内核线程正在查找路径名时，另一个内核线程可能通过取消链接目录来更改目录树。一种潜在的风险是，查找可能正在搜索一个已经被另一个内核线程删除并且其块已经被用于另一个目录或文件的目录。

Xv6 避免了这种竞争。例如，在 `namex` 中执行 `dirlookup` 时，查找线程持有目录上的锁，并且 `dirlookup` 返回一个使用 `iget` 获取的 inode。`iget` 增加了 inode 的引用计数。只有在从 `dirlookup` 接收 inode 之后，`namex` 才释放目录上的锁。现在，另一个线程可能会从目录中取消链接 inode，但是 xv6 不会立即删除 inode，因为 inode 的引用计数仍然大于零。

另一个风险是死锁。例如，当查找 "." 时，`next` 指向与 `ip` 相同的 inode。在释放 `ip` 上的锁之前锁定 `next` 将导致死锁。为避免这种死锁，`namex` 在获取 `next` 上的锁之前解锁目录。在这里，我们再次看到为什么 `iget` 和 `ilock` 之间的分离如此重要。

## 文件描述符层

Unix 接口的一个很酷的方面是，Unix 中的大多数资源都表示为文件，包括控制台等设备、管道以及实际文件。文件描述符层是实现这种一致性的层。

如第 1 章所述，Xv6 为每个进程提供了一个打开文件的表，即文件描述符。每个打开的文件都由一个 `struct file` 表示，该结构位于 inode 或管道周围，以及一个 I/O 偏移量。每次调用 `open` 都会创建一个新的打开文件（一个新的 `struct file`）：如果多个进程独立地打开同一个文件，不同的实例将具有不同的 I/O 偏移量。另一方面，单个打开的文件（相同的 `struct` `file`）可以在一个进程的文件表中出现多次，并且也可以在多个进程的文件表中出现。如果一个进程使用 `open` 打开文件，然后使用 `dup` 创建别名或使用 `fork` 与子进程共享，则会发生这种情况。引用计数跟踪对特定打开文件的引用数量。文件可以用于读取、写入或同时进行读写。`readable` 和 `writable` 字段跟踪这些内容。

系统中的所有打开文件都存储在一个全局文件表中，即 `ftable`。文件表有函数分配文件（`filealloc`）、创建重复引用（`filedup`）、释放引用（`fileclose`）以及读写数据（`fileread` 和 `filewrite`）。

前三个遵循现在熟悉的形式。`filealloc` (kernel/file.c:30) 扫描文件表以查找未引用的文件（`f->ref == 0`）并返回新引用；`filedup` (kernel/file.c:48) 增加引用计数；`fileclose` (kernel/file.c:60) 减少引用计数。当文件的引用计数达到零时，`fileclose` 根据类型释放底层管道或 inode。

函数 `filestat`、`fileread` 和 `filewrite` 实现了对文件的 `stat`、`read` 和 `write` 操作。`filestat` (kernel/file.c:88) 只允许在 inode 上执行，并调用 `stati`。`fileread` 和 `filewrite` 检查打开模式是否允许操作，然后将调用传递给管道或 inode 实现。如果文件代表一个 inode，`fileread` 和 `filewrite` 使用 I/O 偏移量作为操作的偏移量，然后前进  (kernel/file.c:122- 123) (kernel/file.c:153-154).。管道没有偏移量的概念。请回顾 inode 函数要求调用者处理锁定 (kernel/file.c:94-96) (kernel/file.c:121-124) (kernel/file.c:163-166).。inode 锁定具有方便的副作用，即读写偏移量是原子更新的，因此同时写入同一文件的多个操作不能覆盖彼此的数据，尽管它们的写操作可能会交错。

## 代码：系统调用

利用较低层次提供的函数，大多数系统调用的实现非常简单（参见 `kernel/sysfile.c`）。有些调用值得更仔细地看一看。

函数 `sys_link` 和 `sys_unlink` 编辑目录，创建或删除对 inode 的引用。它们是使用事务强大功能的另一个很好的例子。`sys_link` (kernel/sys- file.c:124) 首先获取其参数，两个字符串 `old` 和 `new` (kernel/sysfile.c:129)。假设 `old` 存在且不是目录(kernel/sysfile.c:133-136)，`sys_link` 增加其 `ip->nlink` 计数。然后，`sys_link` 调用 `nameiparent` 找到 `new` 的父目录和最终路径元素（ (kernel/sysfile.c:149)，并创建一个指向 `old` 的 inode 的新目录条目 (kernel/sysfile.c:152)。新的父目录必须存在且与现有 inode 位于同一设备上：inode 号在单个磁盘上才具有唯一含义。如果发生这样的错误，`sys_link` 必须返回并递减 `ip->nlink`。

事务简化了实现，因为它需要更新多个磁盘块，但我们不必担心我们执行它们的顺序。它们要么全部成功，要么一个都不成功。例如，在创建链接之前更新 `ip->nlink` 而不使用事务，将使文件系统暂时处于不安全状态，之间的崩溃可能导致严重问题。使用事务，我们不必担心这个问题。

`sys_link` 为现有的 inode 创建一个新名称。函数 `create` (kernel/sysfile.c:246)为新 inode 创建一个新名称。它是三个文件创建系统调用的泛化：带有 `O_CREATE` 标志的 `open` 创建一个新的普通文件，`mkdir` 创建一个新目录，而 `mkdev` 创建一个新的设备文件。与 `sys_link` 类似，`create` 首先调用 `nameiparent` 获取父目录的 inode。然后调用 `dirlookup` 检查名称是否已存在 (kernel/sysfile.c:256).。如果名称确实存在，`create` 的行为取决于它用于哪个系统调用：`open` 与 `mkdir` 和 `mkdev` 的语义不同。如果 `create` 是代表 `open` 使用的（`type == T_FILE`），并且存在的名称本身是一个常规文件，那么 `open` 将其视为成功，因此 `create` 也是如此 (kernel/sysfile.c:260)。否则，它是一个错误(kernel/sysfile.c:261-262)。如果名称尚不存在，`create` 现在使用 `ialloc` 分配一个新的 inode (kernel/sysfile.c:265)。如果新的 inode 是一个目录，`create` 用 `.` 和 `..` 条目初始化它。最后，现在数据已正确初始化，`create` 可以将其链接到父目录 (kernel/sysfile.c:278)。`create` 和 `sys_link` 一样，同时保持两个 inode 锁：`ip` 和 `dp`。不存在死锁的可能性，因为 inode `ip` 是新分配的：系统中没有其他进程将保持 `ip` 的锁，然后尝试锁定 `dp`。

使用 `create`，可以轻松实现 `sys_open`、`sys_mkdir` 和 `sys_mknod`。`sys_open` 是最复杂的，因为创建一个新文件只是它可以做的一小部分工作。如果 `open` 传递了 `O_CREATE` 标志，它将调用 `create` (kernel/sysfile.c:305)。否则，它调用 `namei` (kernel/sysfile.c:326)。`create` 返回一个锁定的 inode，但 `namei` 不会，因此 `sys_open` 必须自己锁定 inode。这提供了一个方便的地方来检查目录是否仅以读取方式打开，而不是写入方式。假设以某种方式获得了 inode，`sys_open` 分配一个文件和一个文件描述符 (kernel/sysfile.c:344)，然后填充文件 (kernel/sysfile.c:356-361)。请注意，由于它仅位于当前进程的表中，因此其他进程无法访问部分初始化的文件。

第 7 章在我们甚至拥有文件系统之前就检查了管道的实现。函数 `sys_pipe` 通过提供创建管道对的方法将该实现连接到文件系统。它的参数是指向两个整数的空间的指针，它将在其中记录两个新的文件描述符。然后它分配管道并安装文件描述符。

## 现实世界

现实世界中的操作系统的缓冲区缓存要比 xv6 的复杂得多，但它们有相同的两个目的：缓存和同步访问磁盘。Xv6 的缓冲区缓存和 V6 的一样，使用简单的最近最少使用（LRU）替换策略；还有许多更复杂的策略可以实现，每种策略对于某些工作负载很好，对于其他工作负载则不太好。一个更高效的 LRU 缓存会消除链表，而使用散列表进行查找和堆进行 LRU 替换。现代缓冲区缓存通常与虚拟内存系统集成，以支持内存映射文件。

Xv6 的日志系统效率低下。提交不能与文件系统系统调用同时进行。系统记录整个块，即使只更改了块中的几个字节。它执行同步日志写入，每次一个块，每次都可能需要整个磁盘旋转时间。真正的日志系统解决了所有这些问题。

日志记录并非提供崩溃恢复的唯一方法。早期的文件系统在重新启动时使用清道夫（例如 UNIX 的 `fsck` 程序）检查每个文件和目录以及块和 inode 的空闲列表，寻找并解决不一致。对于大型文件系统，清除可能需要数小时，而且在某些情况下，无法以导致原始系统调用原子性的方式解决不一致。从日志中恢复要快得多，而且在崩溃面前会导致系统调用具有原子性。

Xv6 使用与早期 UNIX 相同的基本磁盘 inode 和目录布局；多年来，这种方案一直保持着惊人的持久性。BSD 的 UFS/FFS 和 Linux 的 ext2/ext3 实际上使用相同的数据结构。文件系统布局中最低效的部分是目录，在每次查找过程中都需要对所有磁盘块进行线性扫描。当目录只有几个磁盘块时，这是合理的，但是对于存储大量文件的目录来说，代价很高。仅举几个例子，Microsoft Windows 的 NTFS、macOS 的 HFS 和 Solaris 的 ZFS 将目录实现为磁盘上平衡的块树。这很复杂，但可以保证对数时间的目录查找。

Xv6 对磁盘故障过于简单：如果磁盘操作失败，xv6 就会产生恐慌。这是否合理取决于硬件：如果操作系统位于使用冗余来屏蔽磁盘故障的特殊硬件之上，那么操作系统可能会很少看到故障，因此产生恐慌是可以接受的。另一方面，使用普通磁盘的操作系统应该预料到故障，并更优雅地处理它们，这样一个文件中的一个块的丢失不会影响到文件系统其余部分的使用。

Xv6 要求文件系统适应一个磁盘设备且不改变大小。随着大型数据库和多媒体文件不断推动存储需求增长，操作系统正在开发消除“一个文件系统一个磁盘”的瓶颈的方法。基本方法是将多个磁盘组合成一个逻辑磁盘。硬件解决方案如 RAID 仍然最受欢迎，但当前趋势是尽可能在软件中实现这些逻辑。这些软件实现通常允许通过动态添加或删除磁盘来增大或缩小逻辑设备。当然，可以动态增长或缩小的存储层需要一个可以做到这一点的文件系统：xv6 使用的固定大小的 inode 块数组在这样的环境中效果不佳。将磁盘管理与文件系统分离可能是最干净的设计，但是两者之间复杂的接口使得一些系统，如 Sun 的 ZFS，将它们结合在一起。

Xv6 的文件系统缺少许多现代文件系统的其他功能；例如，它不支持快照和增量备份。

现代 Unix 系统允许许多种资源以与磁盘存储相同的系统调用进行访问：命名管道、网络连接、远程访问的网络文件系统以及监控和控制接口，如 `/proc`。这些系统通常为每个打开的文件提供一个函数指针表，每个操作一个，然后调用函数指针来调用该 inode 的调用实现。网络文件系统和用户级文件系统提供将这些调用转换为网络 RPC 的功能，并在返回之前等待响应。