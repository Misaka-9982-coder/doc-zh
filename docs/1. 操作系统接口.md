# 1. 操作系统接口

操作系统的任务是在多个程序之间共享一台计算机，并提供比硬件本身支持的更有用的服务。操作系统管理和抽象底层硬件，例如文字处理器不需要关心使用哪种类型的磁盘硬件。一个操作系统在多个程序之间共享硬件，这样它们就可以(或者看起来可以)同时运行。最后，操作系统为程序提供了可控的交互方式，这样它们就可以共享数据或者一起工作。

操作系统通过接口向用户程序提供服务。设计良好的接口是很困难的。一方面，我们希望接口简单明了，因为这样更利于正确使用。另一方面，我们可能倾向于为应用程序提供许多复杂的特性。解决这个问题的诀窍在于设计接口时，依赖一些可结合的机制，以此来提供更好的通用性。

本书使用单一的操作系统作为具体的例子来说明操作系统的概念。xv6这个操作系统提供了Ken Thompson和Dennis Ritchie的Unix 介绍的基本接口，并且模仿了Unix的内部设计。Unix提供了一个窄接口，其机制表现突出，提供了令人惊讶的通用程度。这个接口非常成功，甚至现代操作系统BSD、Linux、Mac OSX、Solaris，甚至在一定程度上，Microsoft windows都有类Unix的接口。理解xv6是理解这些系统和其他系统的一个良好开端。

如下图1.1所示，xv6采用传统的内核形式（内核是一个特殊的程序，为正在运行的程序提供服务）。每个正在运行的程序，称为进程，都有包含指令、数据和堆栈的内存。指令实现了程序的运算，数据是计算所依赖的变量，堆栈组织程序的过程调用。一台给定的计算机通常有许多进程，但只有一个内核。

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c1/p1.png)

当一个进程需要调用一个内核服务时，它会调用一个系统调用，这是操作系统接口中的一个调用。系统调用进入内核；内核执行服务并返回。因此，一个进程在用户空间和内核空间之间交替执行。

内核使用CPU提供的硬件保护机制来确保每个在用户空间执行的进程只能访问它自己的内存。内核程序的执行拥有操控硬件的权限，它需要实现这些保护；而用户程序执行时没有这些特权。当用户程序调用系统调用时，硬件会提升权限级别，并开始执行内核中预先安排好的函数。

内核提供的系统调用集合是用户程序看到的接口。Xv6内核提供了Unix内核传统上提供的服务和系统调用的子集。表1.2列出了xv6的所有系统调用。

| **系统调用**                            | **描述**                                                    |
| --------------------------------------- | ----------------------------------------------------------- |
| `int fork()`                            | 创建一个进程，返回子进程的PID                               |
| `int exit(int status)`                  | 终止当前进程，并将状态报告给wait()函数。无返回              |
| `int wait(int *status)`                 | 等待一个子进程退出; 将退出状态存入*status; 返回子进程PID。  |
| `int kill(int pid)`                     | 终止对应PID的进程，返回0，或返回-1表示错误                  |
| `int getpid()`                          | 返回当前进程的PID                                           |
| `int sleep(int n)`                      | 暂停n个时钟节拍                                             |
| `int exec(char *file, char *argv[])`    | 加载一个文件并使用参数执行它; 只有在出错时才返回            |
| `char *sbrk(int n)`                     | 按n 字节增长进程的内存。返回新内存的开始                    |
| `int open(char *file, int flags)`       | 打开一个文件；flags表示read/write；返回一个fd（文件描述符） |
| `int write(int fd, char *buf, int n)`   | 从buf 写n 个字节到文件描述符fd; 返回n                       |
| `int read(int fd, char *buf, int n)`    | 将n 个字节读入buf；返回读取的字节数；如果文件结束，返回0    |
| `int close(int fd)`                     | 释放打开的文件fd                                            |
| `int dup(int fd)`                       | 返回一个新的文件描述符，指向与fd 相同的文件                 |
| `int pipe(int p[])`                     | 创建一个管道，把read/write文件描述符放在p[0]和p[1]中        |
| `int chdir(char *dir)`                  | 改变当前的工作目录                                          |
| `int mkdir(char *dir)`                  | 创建一个新目录                                              |
| `int mknod(char *file, int, int)`       | 创建一个设备文件                                            |
| `int fstat(int fd, struct stat *st)`    | 将打开文件fd的信息放入*st                                   |
| `int stat(char *file, struct stat *st)` | 将指定名称的文件信息放入*st                                 |
| `int link(char *file1, char *file2)`    | 为文件file1创建另一个名称(file2)                            |
| `int unlink(char *file)`                | 删除一个文件                                                |

本章的其余部分概述了 xv6 的服务——进程、内存、文件描述符、管道和文件系统——并通过代码片段和讨论说明了它们的使用方式。Unix 的命令行用户界面—— shell ——使用它们。shell对系统调用的使用说明了它们被如何精心设计。

shell是一个普通的程序，从用户那里读取命令并执行它们。Shell是一个用户程序，而不是内核的一部分，这说明了系统调用接口的强大之处：Shell并没有什么特别之处。这也意味着Shell很容易被替换；因此，现代Unix系统有各种不同的Shell可供选择，每个Shell都有自己的用户界面和脚本功能。xv6 shell 是 Unix Bourne shell 本质的简单实现。其实现可以在 `user/sh.c` 中找到。

## 进程和内存

xv6 进程由用户空间内存（指令、数据和堆栈）以及内核私有的每个进程状态组成。

xv6支持时间共享进程：它在等待执行的进程集合中透明地切换可用的CPU。

当进程没有执行时，xv6会保存进程的CPU寄存器，并在下次运行该进程时恢复它们。

内核关联一个进程标识符，或 `PID`，用于唯一标识每个进程。



一个进程可以使用fork系统调用创建一个新进程。

fork 会给新进程提供与调用进程完全相同的内存，包括指令和数据。

fork 在原始进程和新进程中都返回。在原始进程中，fork 返回新进程的 PID。在新进程中，fork 返回零。通常将原始和新的两个进程称为父进程和子进程。

例如，考虑以下用 C 编写的程序片段：

```c
int pid = fork();
if(pid > 0){
  printf("parent: child=%d\n", pid);
  pid = wait((int *) 0);
  printf("child %d is done\n", pid);
} else if(pid == 0){
  printf("child: exiting\n");
  exit(0);
} else {
  printf("fork error\n");
}
```

exit 系统调用会导致调用进程停止执行并释放资源，如内存和打开的文件。Exit 接受一个整数状态参数，通常为 0 表示成功，1 表示失败。

wait 系统调用返回当前进程已退出或被杀死的子进程的PID，并将子进程的退出状态复制到传递给wait的地址；如果调用者的任何子进程都没有退出，则 wait 等待其中一个子进程退出。

如果调用者没有子进程，则 wait 立即返回 -1。如果父进程不关心子进程的退出状态，则可以将 0 地址传递给 wait。

示例输出

```bash
parent: child=1234
child: exiting
```

可能以任何顺序甚至混合出现，这取决于父进程或子进程先调用printf。

子进程退出后，父进程的 wait 返回，导致父进程打印

```c
parent: child 1234 is done
```

尽管子进程最初具有与父进程相同的内存内容，但父进程和子进程正在使用单独的内存和单独的寄存器执行 : 改变一个变量不会影响另一个变量。例如，在父进程中将 wait 的返回值存储到 pid 中时，它不会改变子进程中的变量 pid 。子进程中 pid 的值仍然为零。

exec 系统调用用一个存储在文件系统中的文件替换调用进程的内存。

该文件必须具有特定的格式，指定文件的哪一部分包含指令，哪一部分是数据，从哪个指令开始等。Xv6使用ELF格式，第三章详细讨论了该格式。通常，该文件是编译程序源代码的结果。

当 exec 成功时，它不会返回到调用程序；相反，从文件加载的指令从 ELF 头中声明的入口点开始执行。

exec 有两个参数：包含要执行的程序的文件的名称。可执行文件和字符串参数数组。

例如：

```c
char *argv[3];

argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```

这个片段用程序 `/bin/echo` 的实例替换了调用程序，并使用参数列表 `echo hello`

大多数程序忽略参数数组的第一个元素，这通常是程序的名称。

xv6 shell 使用上述调用代表用户运行程序。 shell 的主要结构很简单；请参见 `main` `(user/sh.c)`。

主循环从用户那里读取一行输入 `getcmd` ，然后它调用 `fork` 创建了shell进程的副本。 父进程调用 `wait`，而子进程运行命令。 

例如，如果用户在 shell 中键入了 `echo hello`，runcmd 将被调用，并以 `echo hello` 作为参数。 `runcmd`（user / sh.c：55）运行实际命令。对于 “echo hello”，它将调用 exec（user / sh.c：79）。如果 exec 成功，则子进程将执行来自 echo 的指令，而不是 runcmd。在某个时刻，echo 将调用 exit，这会导致父进程从 main 中的 wait 返回（user / sh.c：146）。

你可能会想知道为什么 `fork` 和 `exec` 没有合并为一个调用。我们将在后面看到，这是因为 shell 在实现 I/O重定向时利用了这种分离。为了避免创建一个重复的进程，然后立即(用 exec) 替换它，操作系统内核通过使用虚拟内存技术来优化 `fork` 的实现。

Xv6隐式地分配大部分用户空间内存： fork 为子进程分配所需的内存，以复制父进程的内存； exec 为可执行文件分配足够的内存。需要在运行时分配更多内存（例如使用 malloc ）的进程可以调用 sbrk(n) 来增加其数据内存 n 字节；sbrk 返回新内存的位置。

## I/O和文件描述符

文件描述符是表示进程可以从中读取或写入的内核管理对象的小整数。进程可以通过打开文件、目录或设备、创建管道或复制现有描述符来获得文件描述符。为了简化，我们经常将文件描述符所指的对象称为“文件”；文件描述符接口抽象了文件之间的差异。文件、管道和设备，使它们看起来都像字节流。我们将输入和输出称为 I/O。

在内部，xv6 内核使用文件描述符作为进程表的索引，以便每个进程都有一个从零开始的私有文件描述符空间。

按照惯例，

- 进程从文件描述符 0（标准输入）读取，

- 输出写入文件描述符 1（标准输出），以及

- 将错误消息写入文件描述符 2（标准错误）

正如我们将看到的那样，shell 利用这个约定来实现 I/O 重定向和管道。shell 确保它始终有三个文件描述符打开 (user/sh.c:152)，默认情况下是控制台的文件描述符。

`read` 和 `write` 系统调用从文件描述符命名的打开文件中读取字节并写入字节。

调用 `read(fd，buf，n)` 最多从文件描述符 `fd` 中读取 `n` 个字节，将它们复制到 `buf` 中，并返回已读取的字节数。每个引用文件的文件描述符都有一个与之关联的偏移量。`read` 从当前文件偏移量处读取数据，然后通过所读取的字节数来推进该偏移量：随后的一次 `read` 将返回第一次 `read` 返回后面的字节。当没有更多可读取的字节时，`read` 返回零以表示结束。

调用 `write(fd, buf, n)` 函数将 `buf` 中的 `n` 个字节写入文件描述符 `fd`，并返回已写入的字节数。只有在发生错误时才会写入少于 `n`个字节。与 `read` 类似，`write` 从当前文件偏移量开始写数据，然后通过已写入的字节数来推进该偏移量：每次 `write` 都从上一次结束的地方继续进行。

以下程序片段（它构成了 `cat` 程序的核心）将数据从标准输入复制到标准输出。如果发生错误，它会向标准错误写入一条消息。

```c
char buf[512];
int n;

for (;;) {
  n = read(0, buf, sizeof buf);
  if (n == 0)
    break;
  if (n < 0) {
    fprintf(2, "read error\n");
    exit(1);
  }
  if (write(1, buf, n) != n) {
    fprintf(2, "write error\n");
    exit(1);
  }
}
```

代码片段中需要注意的重要事项是，cat 不知道它是从文件、控制台还是管道中读取数据。同样地，cat 不知道它是将数据打印到控制台、文件还是其他地方。

使用文件描述符和文件描述符 0 是输入，文件描述符 1 是输出的约定，可以简单地实现  cat 。

`close` 系统调用会释放文件描述符，使其可以被未来的 `open`、`pipe` 或 `dup` 系统调用（见下文）重复使用。新分配的文件描述符始终是当前进程中未使用过的最低编号描述符。

文件描述符和 fork 相互作用，使得I/O重定向易于实现。fork 会复制父进程的文件描述符表和内存，因此子进程从与父进程完全相同的打开文件开始。系统调用 exec 替换调用进程的内存，但保留其文件表。这种行为允许shell通过fork实现I/O重定向，重新打开子进程中选择的文件描述符，然后调用 exec 运行新程序。

这是shell运行 `cat < input.txt` 命令的简化代码版本：

```c
char *argv[2];

argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
  close(0);
  open("input.txt", O_RDONLY);
  exec("cat", argv);
}
```



在子进程关闭文件描述符 0 之后，打开操作保证会使用该文件描述符作为新打开的 input.txt 的输入：0 将是最小可用的文件描述符。然后 cat 命令执行时，文件描述符 0（标准输入）指向 input.txt。由于这个序列只修改了子进程的描述符，因此父进程的文件描述符不会被改变。

xv6 shell 中的 I/O 重定向代码正是以这种方式工作的（user/sh.c:83）。请回忆一下，在代码中此时 shell 已经 fork 出了子进程，并且 runcmd 将调用 exec 来加载新程序。

open 的第二个参数由一组标志表示，以位表示，控制 open 的操作。可能的值在文件控制 (fcntl)头文件(**kernel/fcntl.h**:1-5)中定义：`O_RDONLY`，`O_WRONLY`，`O_RDWR`，`O_CREATE`,`O_TRUNC}`  它们指示 open 打开文件以进行读取， 或写入， 或同时进行读写， 如果该文件不存在，则创建该文件， 并将其截断为零长度。

| **宏定义** | **功能说明**             |
| ---------- | ------------------------ |
| `O_RDONLY` | 只读                     |
| `O_WRONLY` | 只写                     |
| `O_RDWR`   | 可读可写                 |
| `O_CREATE` | 如果文件不存在则创建文件 |
| `O_TRUNC`  | 将文件截断为零长度       |

现在应该清楚为什么将 `fork` 和 `exec` 分开是有帮助的了：在这两个调用之间，shell 有机会重定向子进程的 I/O，而不会干扰主 shell 的 I/O 设置。

我们可以想象一个假想的组合 `forkexec` 系统调用，但使用这样的调用进行 I/O 重定向似乎很麻烦。

shell 可以在调用 `forkexec` 之前修改自己的 I/O 设置，然后撤消这些修改；或者 `forkexec` 可以将 I/O 重定向的指令作为参数传递；或者最不可取的是，每个像 `cat` 这样的程序都可以学会自己的 I/O 重定向。

尽管 fork 复制了文件描述符表，但每个底层文件偏移量在父进程和子进程之间是共享的。考虑以下示例：

```c
if(fork() == 0) {
  write(1, "hello ", 6);
  exit(0);
} else {
  wait(0);
  write(1, "world\n", 6);
}
```

在这个片段的结尾，附加到文件描述符1的文件将包含数据“hello world”。父进程中的写操作（由于等待而仅在子进程完成后运行）从子进程的写操作结束处继续。此行为有助于从shell命令序列生成顺序输出，例如 `(echo hello; echo world) >output.txt`。 

`dup` 系统调用复制现有文件描述符，并返回一个新的文件描述符，该描述符引用相同的底层I/O对象。两个文件描述符共享偏移量，就像fork复制的文件描述符一样。这是另一种将“hello world”写入文件中的方法：

```c
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
```

文件描述符是一个强大的抽象概念，它允许进程通过文件描述符来访问文件和其他I/O资源。如果两个文件描述符是由相同的原始文件描述符通过一系列的 fork 和 dup 调用派生而来，那么它们将共享一个偏移量。否则，即使它们是通过open调用打开同一个文件，文件描述符也不会共享偏移量。dup 允许 shell 实现像 `ls existing-file non-existing-file > tmp1 2>&1` 这样的命令，其中 `2>&1` 告诉shell给命令一个文件描述符2，它是描述符1的副本。现在你知道如何实现错误文件描述符的I/O重定向了。

因为它们隐藏了它们连接的细节：写入文件描述符 1 的进程可能会写入文件、像控制台这样的设备或管道。

## 管道

管道是一个小型的内核缓冲区，作为一对文件描述符向进程公开，一个用于读取，一个用于写入。

向管道的一端写入数据使得该数据可以从管道的另一端读取。管道提供了进程间通信的一种方式。

以下示例代码运行程序wc，标准输入连接到管道的读取端。

```c
int p[2];
char *argv[2];

argv[0] = "wc";
argv[1] = 0;

pipe(p);
if(fork() == 0) {
  close(0);
  dup(p[0]);
  close(p[0]);
  close(p[1]);
  exec("/bin/wc", argv);
} else {
  close(p[0]);
  write(p[1], "hello world\n", 12);
  close(p[1]);
}
```



该程序调用 pipe 函数，创建一个新的管道，并将读和写文件描述符记录在数组 p 中。fork 之后，父进程和子进程都有指向管道的文件描述符。子进程调用 close 和 dup 函数，使得文件描述符0指向管道的读端口，关闭了数组 p 中的文件描述符，并调用 exec 运行 wc 命令。当 wc 从标准输入读取时，它会从管道中读取数据。父进程关闭了管道的读端口，在管道中写入数据并关闭了写端口。

如果没有数据可用，管道上的读取将等待数据被写入或所有引用写端的文件描述符关闭；在后一种情况下，读取将返回0，就像到达数据文件的末尾一样。read 阻塞直到不可能有新数据到达是一个原因，这也是重要的孩子在执行wc之前关闭管道的写端口：如果 wc 的其中一个文件描述符引用了管道的写端口，则 wc 将永远看不到文件结束标志。

xv6 shell 实现了管道功能，例如 grep fork sh.c | wc -l，类似于上面的代码（user/sh.c:101）。子进程创建一个管道来连接管道的左端和右端。然后它调用 fork 和 runcmd 来处理管道的左端和右端，并等待两者都完成。 管道的右端可能是一个包含另一个管道（例如 a | b | c）的命令，这将再次分别为 b 和 c 创建两个新的子进程。因此，shell 可以创建一棵进程树。该树的叶子节点是命令，内部节点是等待左右孩子完成的进程。

管道可能看起来比临时文件没有更强大的功能：管道命令   

```bash
echo hello world | wc
```

可以被实现为没有使用管道的形式：   

```bash
 echo hello world >/tmp/xyz; wc </tmp/xyz
```

在这种情况下，相对于临时文件，管道至少有三个优点。

- 首先，管道会自动清理；而使用文件重定向，则需要谨慎地在完成后删除 /tmp/xyz 文件。
- 其次，管道可以传递任意长度的数据流，而文件重定向则需要足够的磁盘空间来存储所有数据。
- 第三，在并行执行流水线阶段方面，使用管道是可行的；然而采用文件方法则要求第一个程序结束后才能开始第二个程序。

## 文件系统

xv6 文件系统提供数据文件，其中包含未解释的字节数组，以及目录，其中包含对数据文件和其他目录的命名引用。这些目录形成一个树，从一个称为根的特殊目录开始。像 /a/b/c 这样的路径是指根目录 / 中名为 a 的目录中名为 b 的目录中名为 c 的文件或目录。不以 / 开头的路径相对于调用进程的当前目录进行评估，可以使用 chdir 系统调用更改当前目录。假设所有涉及的目录都存在，这两个代码片段打开相同的文件：

```c
chdir("/a");
chdir("b");
open("c", O_RDONLY);

open("/a/b/c", O_RDONLY);
```

第一个片段将进程的当前目录更改为/a/b；第二个既不引用也不更改进程的当前目录。

有系统调用来创建新文件和目录：mkdir创建新目录，带有 O_CREATE 标志的 open 创建新数据文件，mknod 创建新设备文件。此示例说明了所有三个：

```c
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

mknod 创建一个引用设备的特殊文件。与设备文件相关联的是主设备号和次设备号，这是 mknod 的两个参数，它们唯一地标识内核设备。当进程稍后打开设备文件时，内核将读取和写入系统调用重定向到内核设备实现，而不是将其传递给文件系统。

一个文件的名称与文件本身是不同的；称为 inode 的相同基础文件可以有多个名字，称为链接。每个链接都包含目录中的条目；该条目包含文件名和对 inode 的引用。 inode 保存有关文件的元数据，包括其类型（文件、目录或设备）、长度、磁盘上内容位置以及对文件的链接数。

fstat系统调用从文件描述符所指向的inode中检索信息。它填充了一个在stat.h（kernel/stat.h）中定义的struct stat：

```c
#define T_DIR     1   // Directory
#define T_FILE    2   // File
#define T_DEVICE  3   // Device

struct stat {
  int dev;     // File system's disk device
  uint ino;    // Inode number
  short type;  // Type of file
  short nlink; // Number of links to file
  uint64 size; // Size of file in bytes
};
```

link 系统调用创建另一个文件系统名称，引用与现有文件相同的 inode。这个片段创建了一个名为 a 和 b 的新文件。

```c
open("a", O_CREATE|O_WRONLY);
link("a", "b");
```

从 a 读取或写入与从b读取或写入相同。每个 inode 由唯一的 inode 号标识。在上面的代码序列之后，可以通过检查 fstat 的结果来确定 a 和 b 引用相同的基础内容：两者都将返回相同的 inode 号（ino），并且 nlink 计数将设置为 2。

unlink 系统调用从文件系统中删除名称。仅当文件链接计数为零且没有文件描述符引用它时，才会释放该文件的 inode 和保存其内容的磁盘空间。因此，在最后一个代码序列中添加

```c
unlink("a");
```

会使 inode 和文件内容作为b可访问。此外， 

```c
fd = open("/tmp/xyz", O_CREATE|O_RDWR); 
unlink("/tmp/xyz");
```

 是一种惯用的方法，可以创建一个没有名称的临时 inode，并在进程关闭 fd 或退出时进行清理。 

Unix 提供了可从 shell 调用的文件实用程序作为用户级程序，例如 mkdir、ln 和 rm。这种设计允许任何人通过添加新的用户级程序来扩展命令行界面。回顾起来，这个计划似乎很明显，但在 Unix 设计时期其他系统通常将这些命令构建到 shell 中（并将 shell 构建到内核中）。

 一个例外是cd，它被构建到 shell 中（user/sh.c:161）。cd 必须更改 shell 本身的当前工作目录。如果像普通命令一样运行 cd，则 Shell 会 fork 出一个子进程，子进程会运行 cd，并且 cd 会更改子进程的工作目录。父进程（即 Shell）的工作目录不会发生变化。



## 实际应用

Unix的“标准”文件描述符、管道和方便的shell语法使得编写通用可重用程序取得了重大进展。这个想法引发了一个“软件工具”文化，为Unix的强大和流行贡献良多，而shell是第一个所谓的“脚本语言”。类似于BSD、Linux和macOS等系统中仍然存在着Unix系统调用接口。通过可移植操作系统接口（POSIX）标准对Unix系统调用接口进行了标准化。Xv6不符合POSIX规范：它缺少许多系统调用（包括基本的lseek等），并且它提供的许多系统调用与标准不同。我们xv6主要目标是简单明了地提供类UNIX风格下简单易懂的系统调用接口。一些人已经扩展了xv6，并添加了一些更多的系统调用以及一个简单C库来运行基本UNIX程序。但现代内核提供比xv6更多种类和类型的内核服务，例如支持网络、窗口管理器、用户级线程、许多设备驱动程序等等，并且在POSIX之外还有很多功能。

Unix使用单一集合文件名和文件描述符界面统一访问各种资源（如文件夹或设备）。这个想法可以扩展到更广泛领域；Plan 9 就是很好例子，将"资源即文件"理念应用到网络、图形等领域上去实现统一界面设计, 然而大部分派生自 Unix 的操作系統沒有遵循這個路線。

文件系統與文件描述符都是強大抽象層次, 卻也有其他作業系統介面模型. Multics 是 Unix 的前身之一，在存储方式上抽象出看起来像内存那样处理数据，从而产生非常不同风格的界面设计. Multics 设计复杂性直接影响到 Unix 设计者们, 他们旨在构建出更加简洁明晰易懂体验. 

Xv6没有提供用户保护机制或区分用户身份; 按照unix术语说,xv6所有进程均以root权限运行。 

该书探究了xv6如何实现其类UNIX界面，但其中涉及到思想与概念适应于除 UNIX 外任何操作系統. 任何操作系統必须将进程映射至底层硬件上，并隔离各个进程并为受控制互相通信提供机制. 学习完 xv6 后, 您应该能够查看其他更复杂操作系統并看到 xv6 中相关原则套路在那些作業系統中同样适配使用.
