# 7. 调度

任何操作系统都可能在计算机拥有的CPU数量之上运行更多的进程，因此需要一个计划来在进程之间共享CPU时间。理想情况下，共享对用户进程来说是透明的。一种常见的方法是通过 **多路复用** 将进程复用到硬件CPU上，为每个进程提供拥有自己的虚拟CPU的错觉。本章将解释xv6如何实现这种多路复用。

## 多路复用

Xv6通过在两种情况下将每个CPU从一个进程切换到另一个进程来实现多路复用。首先，当进程等待设备或管道I/O完成，或等待子进程退出，或在`sleep` 系统调用中等待时，xv6 的`sleep` 和`wakeup` 机制会进行切换。其次，为了应对长时间计算而不休眠的进程，xv6 会定期强制切换。这种多路复用创造了每个进程都拥有自己的CPU的错觉，就像 xv6 使用内存分配器和硬件页表来创造每个进程拥有自己的内存的错觉一样。

实现多路复用需要面对一些挑战。

1. 首先，如何从一个进程切换到另一个进程？虽然上下文切换的概念很简单，但在xv6 中，它的实现是最不透明的代码之一。
2. 其次，如何以对用户进程透明的方式强制切换？xv6 采用了标准技术，即硬件定时器的中断驱动上下文切换。
3. 第三，所有的 CPU 在相同的共享进程集之间进行切换，需要一个锁定计划以避免竞争。
4. 第四，当进程退出时，必须释放进程的内存和其他资源，但它不能完全自己完成这些工作，因为（例如）它不能在仍在使用时释放自己的内核栈。
5. 第五，多核机器的每个核心都必须记住它正在执行的进程，以便系统调用影响正确的进程内核状态。
6. 最后，`sleep` 和 `wakeup` 允许进程放弃CPU并等待被另一个进程或中断唤醒。需要小心避免导致唤醒通知丢失的竞争。尽管 xv6 试图以尽可能简单的方式解决这些问题，但结果代码仍然是棘手的。

## 代码：上下文切换

![](http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c7/p1.png)

图 7.1 描述了从一个用户进程切换到另一个用户进程所涉及的步骤：

1. 用户-内核转换（系统调用或中断）到旧进程的内核线程，
2. 上下文切换到当前CPU的调度器线程，
3. 上下文切换到新进程的内核线程，
4. 以及陷阱返回到用户级进程。

xv6 调度器为每个 CPU 分配一个专用线程（保存的寄存器和堆栈），因为调度器在旧进程的内核堆栈上执行是不安全的：其他内核可能会唤醒进程并运行它，而在两个不同的内核上使用相同的堆栈将是一场灾难。在本节中，我们将研究在内核线程和调度器线程之间切换的机制。

从一个线程切换到另一个线程涉及保存旧线程的CPU寄存器，并恢复新线程先前保存的寄存器；事实上，堆栈指针和程序计数器被保存和恢复意味着CPU将切换堆栈并切换正在执行的代码。

函数`swtch`执行内核线程切换的保存和恢复。`swtch` 并不直接了解线程；它只是保存和恢复一组 32 个 RISC-V 寄存器，称为**上下文** (*contexts*)。当一个进程需要放弃CPU时，进程的内核线程调用 `swtch` 来保存它自己的上下文并返回到调度器上下文。每个上下文包含在一个`struct context` (kernel/proc.h:2)中，它本身包含在一个进程的`struct proc` 或一个CPU的 `struct cpu` 中。`swtch` 接受两个参数：`struct context *old` 和 `struct context *new`。它将当前寄存器保存在 `old` 中，从 `new` 中加载寄存器，并返回。

让我们跟随一个进程通过 `swtch` 进入调度器。我们在第 4 章中看到，在中断结束时，一种可能性是 `usertrap` 调用 `yield` 。`yield` 反过来又调用 `sched` ，它调用 `swtch` 将当前上下文保存在 `p->context`中，并切换到以前保存在 `cpu->context`  (kernel/proc.c:497) 中的调度器上下文。

`swtch` (kernel/swtch.S:3) 仅保存被调用方保存的寄存器(callee)；C 编译器在调用者(caller)中生成将调用者保存的寄存器保存在堆栈上的代码。`swtch` 知道每个寄存器的字段在 `struct context` 中的偏移量。它不保存程序计数器。相反，`swtch` 保存 `ra` 寄存器，其中包含从 `swtch` 被调用的返回地址。现在，`swtch` 从新上下文中恢复寄存器，该上下文保存了之前 `swtch` 保存的寄存器值。当 `swtch` 返回时，它返回到由恢复的 `ra` 寄存器指向的指令，即新线程之前调用 `swtch` 的指令。此外，它返回到新线程的堆栈上，因为这就是恢复的 `sp` 所指向的地方。

在我们的例子中，`sched` 调用 `swtch` 切换到 `cpu->context`，即每个CPU的调度器上下文。该上下文在过去的某个时刻保存，即当 `scheduler` 调用 `swtch` (kernel/proc.c:463) 切换到现在放弃CPU的进程时。当我们一直在追踪的 `swtch` 返回时，它不是返回到 `sched`，而是返回到 `scheduler`，当前 CPU 的调度器堆栈中的堆栈指针。

## 代码：调度

上一节我们讨论了 `swtch` 的底层细节；现在让我们把 `swtch` 当作一个已知的函数，检查从一个进程的内核线程通过调度器切换到另一个进程的过程。调度器以每个CPU上的一个特殊线程的形式存在，每个线程都运行 `scheduler` 函数。这个函数负责选择下一个要运行的进程。想要放弃CPU的进程必须获取自己的进程锁 `p->lock`，释放它持有的其他锁，更新自己的状态（`p->state`），然后调用 `sched`。您可以在 `yield`(kernel/proc.c:503)、`sleep` 和 `exit` 中看到这个序列。`sched` 对这些要求进行双重检查(kernel/proc.c:487-492)，然后检查一个含义：由于锁被持有，中断应该被禁用。最后，`sched ` 调用 `swtch` 将当前上下文保存在 `p->context` 中，并切换到 `cpu->context` 中的调度器上下文。`swtch` 在调度器的堆栈上返回，就像 `scheduler` 的 `swtch` 已经返回(kernel/proc.c:463)。调度器继续执行 `for` 循环，找到要运行的进程，切换到它，然后循环重复。

我们刚刚看到xv6在调用 `swtch` 时保持 `p->lock`：`swtch` 的调用者必须已经持有锁，并且锁的控制权传递给被切换到的代码。这个约定对于锁来说是不寻常的；通常情况下，获取锁的线程也负责释放锁，这样更容易推理正确性。对于上下文切换，由于`p->lock` 在执行 `swtch` 时保护进程的 `state` 和 `context` 字段上的不变式，所以有必要打破这个约定。如果在 `swtch` 期间不持有 `p->lock`，可能会出现的一个问题是：在 `yield` 将其状态设置为 `RUNNABLE` 之后，但在 `swtch ` 导致它停止使用自己的内核栈之前，另一个CPU可能决定运行该进程。结果将是两个CPU在同一个栈上运行，这将导致混乱。

内核线程放弃其CPU的唯一地方是在`sched`中，它总是切换到`scheduler`中的相同位置，这（几乎）总是切换到先前调用`sched`的某个内核线程。因此，如果要打印出xv6切换线程的行号，会观察到以下简单的模式：(kernel/proc.c:463)，(kernel/proc.c:497)，(kernel/proc.c:463)，(kernel/proc.c:497)等等。有意通过线程切换将控制权传递给对方的过程有时被称为**coroutines**；在这个例子中，`sched`和`scheduler`是彼此的协程。

调度器调用`swtch`的一个情况不会在`sched`中结束。`allocproc`将新进程的上下文`ra`寄存器设置为`forkret`(kernel/proc.c:515)，以便它的第一个`swtch`“返回”到该函数的开头。`forkret`的存在是为了释放`p->lock`；否则，由于新进程需要返回到用户空间，就好像从`fork`返回一样，它可以在`usertrapret`处开始。

`scheduler`(kernel/proc.c:445)运行一个循环：找到要运行的进程，运行它直到它放弃CPU，然后重复。调度器遍历进程表，寻找一个可运行的进程，即 `p->state == RUNNABLE` 的进程。一旦找到一个进程，它设置每个CPU当前进程变量 `c->proc`，将进程标记为 `RUNNING`，然后调用 `swtch` 开始运行它(kernel/proc.c:458-463)。

关于调度代码结构的一种思考方式是，它强制执行关于每个进程的一组不变式，并在这些不变式不成立时持有 `p->lock`。一个不变式是，如果一个进程处于 `RUNNING` 状态，定时器中断的 `yield` 必须能够安全地切换离开该进程；这意味着CPU寄存器必须保存进程的寄存器值（即`swtch`尚未将它们移动到一个`context`），并且`c->proc`必须引用该进程。另一个不变式是，如果一个进程是`RUNNABLE`，那么对于一个空闲的CPU的`scheduler`来说，运行它是安全的；这意味着`p->context`必须保存进程的寄存器（即它们实际上不在真正的寄存器中），没有CPU在进程的内核栈上执行，并且没有CPU的`c->proc`引用该进程。请注意，当`p->lock`被持有时，这些属性通常不成立。

维护上述不变式是xv6经常在一个线程中获取`p->lock`并在另一个线程中释放它的原因，例如在`yield`中获取并在`scheduler`中释放。一旦`yield`开始修改一个正在运行的进程的状态，使其变为`RUNNABLE`，锁必须保持锁定状态，直到恢复不变式：最早的正确释放点是在`scheduler`（在其自己的堆栈上运行）清除`c->proc`之后。类似地，一旦`scheduler`开始将一个`RUNNABLE`进程转换为`RUNNING`，在内核线程完全运行之前（例如在`swtch`之后，在`yield`中）不能释放锁。

## 代码：mycpu和myproc

Xv6经常需要指向当前进程的`proc`结构的指针。在单处理器上，可以有一个全局变量指向当前的`proc`。这在多核机器上行不通，因为每个核心执行不同的进程。解决这个问题的方法是利用每个核心都有自己的寄存器集的事实；我们可以使用其中一个寄存器来帮助查找每个核心的信息。

Xv6为每个CPU维护一个`struct cpu`(kernel/proc.h:22)，记录当前在该CPU上运行的进程（如果有的话）、保存CPU调度器线程的寄存器以及管理中断禁用所需的嵌套自旋锁计数。函数`mycpu`(kernel/proc.c:74)返回指向当前CPU的`struct cpu`的指针。RISC-V为其CPU编号，为每个CPU分配一个 **hartid**。Xv6确保每个CPU的 **hartid** 在内核中存储在该CPU的`tp`寄存器中。这允许`mycpu`使用`tp`对`cpu`结构的数组进行索引，以找到正确的结构。

确保CPU的`tp`始终保存CPU的 **hartid** 有点复杂。在CPU引导序列的早期，`start`会在机器模式下设置`tp`寄存器(kernel/start.c:51)。`usertrapret`将`tp`保存在弹簧页(trampoline page)中，因为用户进程可能会修改`tp`。最后，当从用户空间进入内核时，`uservec`会恢复保存的`tp`(kernel/trampoline.S:77)。编译器保证从不使用`tp`寄存器。如果xv6可以在需要时要求RISC-V硬件提供当前的 **hartid**，那将更方便，但RISC-V只允许在机器模式下进行，而不是在监督器模式下。

`cpuid`和`mycpu`的返回值是脆弱的：如果计时器中断并导致线程让步，然后移动到不同的CPU，以前返回的值将不再正确。为避免这个问题，xv6要求调用者禁用中断，并在使用完返回的`struct cpu`之后启用它们。

函数`myproc`(kernel/proc.c:83)返回当前CPU上运行的进程的`struct proc`指针。`myproc`禁用中断，调用`mycpu`，从`struct cpu`中获取当前进程指针（`c->proc`），然后启用中断。即使中断被启用，`myproc`的返回值也是安全的：如果计时器中断将调用进程移动到不同的CPU，其`struct proc`指针将保持不变。

## 睡眠和唤醒

调度和锁有助于将一个线程的操作对另一个线程隐藏，但我们还需要抽象来帮助线程有意地互动。例如，xv6中的管道读取器可能需要等待写入进程产生数据；父进程的`wait`调用可能需要等待子进程退出；处理读取磁盘的进程需要等待磁盘硬件完成读取。在这些情况（以及其他许多情况）下，xv6内核使用一种称为睡眠和唤醒的机制。睡眠允许内核线程等待特定的事件；另一个线程可以调用唤醒来指示等待某个事件的线程应该恢复。睡眠和唤醒通常被称为**顺序协调**或**条件同步**机制。

睡眠和唤醒提供了一个相对较低级别的同步接口。为了激发它们在xv6中的工作方式，我们将使用它们构建一个更高级别的同步机制，称为**信号量**，用于协调生产者和消费者（xv6并未使用信号量）。信号量维护一个计数，并提供两个操作。"V"操作（对于生产者）增加计数。"P"操作（对于消费者）等待计数为非零，然后减少计数并返回。如果只有一个生产者线程和一个消费者线程，它们在不同的CPU上执行，并且编译器不会过于激进地优化，那么这个实现将是正确的：

  ```c
struct semaphore {
    struct spinlock lock;
    int count;
};

  void
  V(struct semaphore *s)
  {
     acquire(&s->lock);
     s->count += 1;
     release(&s->lock);
  }

  void
  P(struct semaphore *s)
  {
     while(s->count == 0)
       ;
     acquire(&s->lock);
     s->count -= 1;
     release(&s->lock);
  }
  ```

上面的实现代价昂贵。如果生产者行为很少，消费者将花费大部分时间在`while`循环中等待非零计数。消费者的CPU可能比**忙等待**通过重复**轮询**`s->count`找到更有成效的工作。避免忙等待需要一种方法让消费者放弃CPU，并在`V`增加计数之后才恢复。

这是朝这个方向迈出的一步，尽管我们会发现这还不够。让我们想象一对调用，`sleep`和`wakeup`，它们的工作方式如下。`sleep(chan)`在任意值`chan`上睡眠，称为**等待通道**。`sleep`使调用进程进入睡眠状态，为其他工作释放CPU。`wakeup(chan)`唤醒所有在`chan`上睡眠的进程（如果有），导致它们的`sleep`调用返回。如果没有进程在`chan`上等待，`wakeup`什么也不做。我们可以将信号量实现更改为使用`sleep`和`wakeup`（突出显示的更改为黄色）：

  ```c
void
  V(struct semaphore *s)
  {
     acquire(&s->lock);
     s->count += 1;
     wakeup(s);
     release(&s->lock);
  }
  
  void
  P(struct semaphore *s)
  {
    while(s->count == 0)
      sleep(s);
    acquire(&s->lock);
    s->count -= 1;
    release(&s->lock);
  }
  ```

现在，`P`放弃CPU而不是旋转，这很好。然而，事实证明，要设计`sleep`和`wakeup`这样的接口，而不受到所谓的**丢失唤醒**问题的困扰，并不简单。假设`P`发现在第212行`s->count==0`。当`P`在第212行和第213行之间时，`V`在另一个CPU上运行：它将`s->count`更改为非零并调用`wakeup`，后者发现没有进程在睡眠，因此什么也不做。现在`P`继续在第213行执行：它调用`sleep`并进入睡眠状态。这会导致一个问题：`P`在等待一个已经发生的`V`调用。除非我们走运，生产者再次调用`V`，否则消费者将永远等待，即使计数为非零。

这个问题的根源是，由于`V`在错误的时刻运行，`P`仅在`s->count == 0`时睡眠的不变式被破坏了。一个不正确的保护不变式的方法是将`P`中的锁获取（在下面以黄色高亮）移动，使其对计数的检查和对`sleep`的调用是原子的：

  ```c
void
  V(struct semaphore *s)
  {
    acquire(&s->lock);
    s->count += 1;
    wakeup(s);
    release(&s->lock);
}
  
  void
  P(struct semaphore *s)
  {
    acquire(\&s->lock);
    while(s->count == 0)
      sleep(s);
    s->count -= 1;
    release(&s->lock);
  }
  ```

人们可能希望这个版本的`P`可以避免丢失唤醒，因为锁阻止`V`在第 313 行和第 314行之间执行。它确实做到了这一点，但它也陷入了死锁：`P`在睡眠时持有锁，所以`V`将永远阻塞等待锁。

我们将通过更改`sleep`的接口来修复前面的方案：调用者必须将**条件锁** 传递给`sleep`，以便在调用进程被标记为在睡眠通道上睡眠和等待之后释放锁。锁将强制并发的`V`等待，直到`P`完成将自己置于睡眠状态，这样`wakeup`就会发现正在睡眠的消费者并唤醒它。一旦消费者再次醒来，`sleep`在返回之前重新获取锁。我们的新正确的睡眠/唤醒方案可用如下（突出显示的更改为黄色）：

  ```c
void
  V(struct semaphore *s)
  {
    acquire(&s->lock);
    s->count += 1;
    wakeup(s);
    release(&s->lock);
	}

  void
  P(struct semaphore *s)
  {
    acquire(&s->lock);
    while(s->count == 0)
       sleep(s, \&s->lock);
    s->count -= 1;
    release(&s->lock);
  }
  ```

事实上，`P`持有`s->lock`可以防止`V`在`P`检查`s->count`和调用`sleep`之间尝试唤醒它。然而，需要注意的是，为了避免丢失唤醒，我们需要`sleep`原子地释放`s->lock`并使消费进程进入睡眠状态。

## 代码：Sleep 和 wakeup

Xv6 的 `sleep` (kernel/proc.c:536) 和 `wakeup` (kernel/proc.c:567) 提供了上面最后一个示例中展示的接口，它们的实现（加上如何使用它们的规则）确保没有丢失唤醒。基本思路是让 `sleep` 将当前进程标记为 `SLEEPING`，然后调用 `sched` 以释放 CPU；`wakeup` 查找在给定等待通道上睡眠的进程，并将其标记为 `RUNNABLE`。调用 `sleep` 和 `wakeup` 的程序可以使用任何相互方便的数字作为通道。Xv6 通常使用与等待有关的内核数据结构的地址。

`sleep` 获取 `p->lock` (kernel/proc.c:547)。现在，进入睡眠的进程同时持有 `p->lock` 和 `lk`。在调用方（在示例中为 `P`）中持有 `lk` 是必要的：它确保没有其他进程（在示例中，运行 `V` 的进程）可以开始调用 `wakeup(chan)`。现在 `sleep` 持有 `p->lock`，释放 `lk` 是安全的：其他进程可能开始调用 `wakeup(chan)`，但 `wakeup` 将等待获取 `p->lock`，因此将等待 `sleep` 完成使进程进入睡眠，使得 `wakeup` 不会错过 `sleep`。

现在，`sleep` 持有 `p->lock`，而没有其他锁，它可以通过记录睡眠通道，将进程状态更改为 `SLEEPING`，并调用 `sched` (kernel/proc.c:551-554) 将进程置于睡眠状态。过一会儿将清楚为什么在进程标记为 `SLEEPING` 之后，`p->lock` 不被释放（由 `scheduler`）是至关重要的。

在某个时候，一个进程将获得条件锁，设置等待睡眠进程的条件，并调用 `wakeup(chan)`。在持有条件锁的情况下调用 `wakeup` 是很重要的.

>  严格来说，如果 `wakeup` 仅在 `acquire` 之后（也就是说，可以在 `release` 之后调用 `wakeup`）就足够了。

`wakeup` 在进程表上循环 (kernel/proc.c:567)。它会获取每个检查过的进程的 `p->lock`，因为它可能会操作该进程的状态，而且 `p->lock` 确保 `sleep` 和 `wakeup` 不会错过彼此。当 `wakeup` 发现一个处于 `SLEEPING` 状态并且具有匹配的 `chan` 的进程时，它会将该进程的状态更改为 `RUNNABLE`。下次调度程序运行时，它将看到该进程已准备好运行。

为什么 `sleep` 和 `wakeup` 的锁定规则可以确保睡眠进程不会错过唤醒？睡眠进程在检查条件之前的某个时间点持有条件锁或其自身的 `p->lock`，或者在标记为 `SLEEPING` 之后的某个时间点持有这两者。在 `wakeup` 的循环中，调用 `wakeup` 的进程持有这两个锁中的每一个。因此，唤醒者要么在消费者线程检查条件之前使条件变为真实，要么唤醒者的 `wakeup` 在被标记为 `SLEEPING` 之后严格地检查睡眠线程。然后，`wakeup` 将看到睡眠进程并唤醒它（除非其他事物先将其唤醒）。

有时候，多个进程会在同一个通道上睡眠；例如，多个进程从管道中读取数据。单个调用 `wakeup` 将唤醒它们所有。其中一个进程将首先运行并获取 `sleep` 被调用时的锁，然后（在管道的情况下）读取管道中等待的数据。其他进程会发现，尽管被唤醒了，但没有数据可读。从它们的角度来看，唤醒是“虚假的”，它们必须再次睡眠。因此，`sleep` 总是在检查条件的循环中被调用。

如果两个使用 sleep/wakeup 的进程不小心选择了相同的通道，也不会造成任何损害：它们会看到虚假的唤醒，但如上所述的循环将容忍这个问题。sleep/wakeup 的魅力在于它既轻量级（无需创建特殊的数据结构充当睡眠通道），又提供了一个间接层（调用者无需知道它们正在与哪个特定的进程交互）。

## 代码：管道

一个更复杂的示例，使用 `sleep` 和 `wakeup` 来同步生产者和消费者，是 xv6 对管道的实现。我们在第 1章中看到了管道的接口：写入管道一端的字节被复制到内核缓冲区，然后可以从管道的另一端读取。后续章节将研究围绕管道的文件描述符支持，但让我们现在看看 `pipewrite` 和 `piperead` 的实现。

每个管道由一个 `struct pipe` 表示，其中包含一个 `lock` 和一个 `data` 缓冲区。字段 `nread` 和 `nwrite` 分别计算从缓冲区读取和写入的总字节数。缓冲区是环绕的：在 `buf[PIPESIZE-1]` 之后写入的下一个字节是 `buf[0]`。计数不回绕。这种约定让实现区分满缓冲区（`nwrite == nread+PIPESIZE`）和空缓冲区（`nwrite == nread`），但这意味着索引到缓冲区必须使用 `buf[nread % PIPESIZE]` 而不是仅使用 `buf[nread]`（对于 `nwrite` 也是类似的）。

假设对 `piperead` 和 `pipewrite` 的调用同时发生在两个不同的 CPU 上。 `pipewrite` (kernel/pipe.c:77) 首先获取管道的锁，该锁保护计数、数据及其关联的不变式。`piperead` (kernel/pipe.c:106) 然后尝试获取锁，但无法获取。它在 `acquire` (kernel/spinlock.c:22) 中自旋，等待锁。在 `piperead` 等待时，`pipewrite` 对要写入的字节（`addr[0..n-1]`）进行循环，依次将每个字节添加到管道中 (kernel/pipe.c:95)。在这个循环中，缓冲区可能会被填满 (kernel/pipe.c:88)。在这种情况下，`pipewrite` 调用 `wakeup` 以提醒任何正在休眠的读者缓冲区中有等待的数据，然后在 `&pi->nwrite` 上休眠，等待读者从缓冲区中取出一些字节。`sleep` 作为将 `pipewrite` 的进程置于休眠状态的一部分，释放 `pi->lock`。

现在 `pi->lock` 可用，`piperead` 成功获取到它并进入临界区：它发现 `pi->nread != pi->nwrite` (kernel/pipe.c:113)（`pipewrite` 休眠是因为 `pi->nwrite == pi->nread+PIPESIZE` (kernel/pipe.c:88)），所以它执行了 `for` 循环，从管道中复制数据 (kernel/pipe.c:120)，并将 `nread` 增加复制的字节数。现在有这么多字节可以写入，所以 `piperead` 调用 `wakeup` (kernel/pipe.c:127) 在返回之前唤醒任何正在休眠的写者。`wakeup` 发现一个在 `&pi->nwrite` 上休眠的进程，即执行 `pipewrite` 但在缓冲区填满时停止的进程。它将该进程标记为 `RUNNABLE`。

管道代码对读者和写者使用了单独的睡眠通道（`pi->nread` 和 `pi->nwrite`）；如果同一个管道有许多读者和写者在等待，这可能会使系统在不太可能的情况下更加高效。管道代码在检查睡眠条件的循环中休眠；如果有多个读者或写者，除第一个唤醒的进程外，其他进程都会发现条件仍然为假并再次休眠。

## 代码：Wait、exit 和 kill

 `sleep` 和 `wakeup` 可用于许多类型的等待。一个有趣的例子是在第 1 章中引入的子进程的 `exit` 与其父进程的 `wait` 之间的交互。在子进程死亡时，父进程可能已经在 `wait` 中睡眠，或者正在做其他事情；在后一种情况下，后续对 `wait` 的调用必须观察到子进程的死亡，也许在 `exit` 调用很久之后。xv6 记录子进程死亡直到 `wait` 观察到它的方式是让 `exit` 将调用者置于 `ZOMBIE` 状态，在父进程的 `wait` 注意到它，将子进程的状态更改为 `UNUSED`，复制子进程的退出状态，并将子进程的进程 ID 返回给父进程之前，子进程一直保持在该状态。如果父进程在子进程之前退出，父进程会将子进程交给 `init` 进程，后者会持续调用 `wait`；因此，每个子进程都有一个父进程来清理它。挑战是避免在同时发生的父进程和子进程之间的 `wait` 和 `exit` 以及同时发生的 `exit` 和 `exit` 之间的竞争和死锁。

`wait` 首先获取 `wait_lock` (kernel/proc.c:391)。原因是 `wait_lock` 充当条件锁，有助于确保父进程不会错过退出子进程的 `wakeup`。然后 `wait` 扫描进程表。如果找到处于 `ZOMBIE` 状态的子进程，它会释放该子进程的资源和其 `proc` 结构，将子进程的退出状态复制到提供给 `wait` 的地址（如果不为 0），并返回子进程的进程 ID。如果 `wait` 找到子进程但没有退出，它会调用 `sleep` 等待其中任何一个退出 (kernel/proc.c:433)，然后再次扫描。在 `wait_lock` 和某个进程的 `pp->lock` 之间，`wait` 通常持有两个锁；避免死锁的顺序是先 `wait_lock` 然后是 `pp->lock`。

`exit` (kernel/proc.c:347) 记录退出状态，释放一些资源，调用 `reparent` 将其子进程交给 `init` 进程，唤醒父进程以防其处于 `wait`，将调用者标记为僵尸，并永久放弃 CPU。在这个过程中，`exit` 保持着 `wait_lock` 和 `p->lock`。它保持 `wait_lock` 是因为它是 `wakeup(p->parent)` 的条件锁，防止 `wait` 中的父进程丢失唤醒。在这个过程中，`exit` 也必须保持 `p->lock`，以防止 `wait` 中的父进程在子进程最终调用 `swtch` 之前看到子进程处于 `ZOMBIE` 状态。`exit` 按照与 `wait` 相同的顺序获取这些锁，以避免死锁。

`exit` 在将其状态设置为 `ZOMBIE` 之前唤醒父进程看起来可能是错误的，但实际上是安全的：尽管 `wakeup` 可能导致父进程运行，但是 `wait` 中的循环在子进程的 `p->lock` 被  `scheduler` 释放之前无法检查子进程，因此在 `exit` 将其状态设置为 `ZOMBIE` 很久之后，`wait` 才能查看退出的进程 (kernel/proc.c:379)。

虽然 `exit` 允许进程终止自身，但 `kill` (kernel/proc.c:586) 让一个进程请求另一个进程终止。如果 `kill` 直接销毁受害进程将过于复杂，因为受害者可能在另一个 CPU 上执行，也许是在对内核数据结构进行敏感的更新序列中间。因此，`kill` 做得非常少：它只是设置受害者的 `p->killed`，如果它处于睡眠状态，就唤醒它。最终，受害者将进入或离开内核，此时，如果设置了 `p->killed`，`usertrap` 中的代码将调用 `exit`（通过调用 `killed` 进行检查 (kernel/proc.c:615)）。如果受害者正在用户空间中运行，那么很快会通过发起系统调用或因计时器（或其他设备）中断进入内核。

如果受害进程处于 `sleep` 状态，`kill` 对 `wakeup` 的调用将导致受害进程从 `sleep` 返回。这可能是危险的，因为可能等待的条件并不成立。然而，xv6 对 `sleep` 的调用总是用一个 `while` 循环包装起来，在 `sleep` 返回后重新测试条件。一些调用 `sleep` 的循环还检查 `p->killed`，如果设置了该值，它们将放弃当前的活动。只有在放弃正确的情况下才会这样做。例如，管道读写代码如果设置了 killed 标志，则返回；最终代码将返回到陷阱，再次检查 `p->killed` 并退出。

一些 xv6 的 `sleep` 循环没有检查 `p->killed`，因为代码处于一个多步骤的系统调用中，这个系统调用应该是原子的。virtio 驱动程序 (kernel/virtio\_disk.c:285) 就是一个例子：它没有检查 `p->killed`，因为磁盘操作可能是一组写操作中的一个，所有这些写操作都需要使文件系统保持在正确的状态。在等待磁盘 I/O 时被杀死的进程将在完成当前的系统调用并且 `usertrap` 看到 killed 标志后退出。

## 进程锁定

与每个进程关联的锁（`p->lock`）是 xv6 中最复杂的锁。简单地认为，`p->lock` 在读取或写入以下 `struct proc` 字段时必须被持有：`p->state`，`p->chan`，`p->killed`，`p->xstate` 和 `p->pid`。这些字段可以被其他进程或其他内核线程使用，因此它们必须受到锁的保护。

然而，大多数使用 `p->lock` 的地方都在保护 xv6 的进程数据结构和算法的更高级别方面。以下是 `p->lock` 所做的全部事情：

- 和 `p->state` 一起，防止在为新进程分配 `proc[]` 插槽时发生竞争。
- 在进程被创建或销毁时，将其从视图中隐藏。使分配、销毁的所有步骤原子化。
- 防止父进程的 `wait` 收集已将其状态设置为 `ZOMBIE` 但尚未放弃 CPU 的进程。

- 防止另一个内核的调度器在进程将其状态设置为 `RUNNABLE` 但尚未完成 `swtch` 之前决定运行正在让出的进程。
- 确保只有一个内核的调度器决定运行 `RUNNABLE` 进程。
- 防止定时器中断导致进程在 `swtch` 中让出。
- 和条件锁一起，有助于防止 `wakeup` 忽略一个正在调用 `sleep` 但尚未完成放弃 CPU 的进程。
- 防止 `kill` 的受害进程在 `kill` 检查 `p->pid` 和设置 `p->killed` 之间退出并可能被重新分配。
- 使 `kill` 对 `p->state` 的检查和写入原子化。

`p->parent` 字段由全局锁 `wait_lock` 保护，而不是由 `p->lock` 保护。只有进程的父进程修改 `p->parent`，尽管该字段既被进程本身读取，也被其他进程在搜索其子进程时读取。 `wait_lock` 的目的是在 `wait` 睡眠等待任何子进程退出时充当条件锁。退出的子进程持有 `wait_lock` 或 `p->lock`，直到它将其状态设置为 `ZOMBIE`，唤醒其父进程，并放弃 CPU。 `wait_lock` 还对父进程和子进程的并发 `exit` 进行序列化，以便保证 `init` 进程（继承子进程）从其 `wait` 中被唤醒。`wait_lock` 是一个全局锁，而不是每个父进程中的每个进程锁，因为在进程获取它之前，它不能知道谁是其父进程。

## 现实世界

xv6 调度器实现了一个简单的调度策略，依次运行每个进程。这种策略被称为**轮询**。现实中的操作系统实现了更复杂的策略，例如，允许进程具有优先级。这样的想法是，可运行的高优先级进程将优先于可运行的低优先级进程。这些策略很快变得复杂，因为通常有竞争目标：例如，操作系统可能还希望保证公平性和高吞吐量。此外，复杂的策略可能导致意外的相互作用，例如 **优先级反转** 和 **护航**。当低优先级和高优先级的进程都使用特定的锁时，优先级反转可能会发生，这会导致低优先级进程获取锁时，高优先级进程无法取得进展。当许多高优先级进程等待获取共享锁的低优先级进程时，可以形成一个长队列的等待进程；一旦形成护航，它可能会持续很长时间。为了避免这类问题，复杂的调度器中需要额外的机制。

`sleep` 和 `wakeup` 是一种简单而有效的同步方法，但还有许多其他方法。它们的第一个挑战是避免我们在本章开头看到的“丢失唤醒”问题。原始 Unix 内核的 `sleep` 只需禁用中断，因为 Unix 在单 CPU 系统上运行。由于 xv6 在多处理器上运行，它在 `sleep` 中添加了一个显式锁。FreeBSD 的 `msleep` 采用相同的方法。Plan 9 的 `sleep` 使用一个在睡眠前持有调度锁的回调函数；该函数用作最后一刻的睡眠条件检查，以避免丢失唤醒。Linux 内核的 `sleep` 使用一个显式的进程队列，称为等待队列，而不是等待通道；队列有其自己的内部锁。

在 `wakeup` 中扫描所有进程集合是低效的。一个更好的解决方案是用一个保存在该结构上睡眠的进程列表的数据结构替换 `sleep` 和 `wakeup` 中的 `chan`，比如 Linux 的等待队列。Plan 9 的 `sleep` 和 `wakeup` 将该结构称为汇合点。许多线程库将相同的结构称为条件变量；在这种情况下，操作 `sleep` 和 `wakeup` 分别称为 `wait` 和 `signal`。所有这些机制都具有相同的特点：睡眠条件受到某种在睡眠期间原子性丢弃的锁的保护。

`wakeup` 的实现会唤醒在特定通道上等待的所有进程，可能有许多进程正在等待那个特定的通道。操作系统将调度所有这些进程，它们将争先恐后地检查睡眠条件。有时被称为**雷鸣般的一群** (*thundering herd*) 的进程以这种方式行为，最好避免。大多数条件变量都有两个 `wakeup` 原语：`signal`，唤醒一个进程，和 `broadcast`，唤醒所有等待的进程。

信号量通常用于同步。计数通常对应于类似于管道缓冲区中可用字节数或进程具有的僵尸子进程数量之类的东西。将显式计数作为抽象的一部分可以避免“丢失唤醒”(“lost wakeup” )的问题：有一个唤醒次数的显式计数。计数还可以避免虚假唤醒和雷鸣般的一群问题。

终止进程并清理它们在 xv6 中引入了很多复杂性。在大多数操作系统中，它甚至更加复杂，因为例如，受害进程可能在内核深处睡眠，小心解开其堆栈，因为调用堆栈上的每个函数可能都需要进行一些清理。有些语言通过提供异常机制来提供帮助，但 C 语言没有。此外，还有其他事件可能导致睡眠进程被唤醒，尽管它等待的事件尚未发生。例如，当 Unix 进程处于睡眠状态时，另一个进程可能会向其发送 `signal`。在这种情况下，进程将从中断的系统调用返回值 -1，并将错误代码设置为 EINTR。应用程序可以检查这些值并决定如何处理。Xv6 不支持信号，因此不会产生这种复杂性。

Xv6 对 `kill` 的支持并不完全令人满意：有些睡眠循环可能应该检查 `p->killed`。相关问题是，即使对于检查 `p->killed` 的 `sleep` 循环，`sleep` 和 `kill` 之间也存在竞争；后者可能在受害者循环检查 `p->killed` 之后，但在调用 `sleep` 之前设置 `p->killed` 并尝试唤醒受害者。如果出现这个问题，受害者在等待的条件发生之前都不会注意到 `p->killed`。这可能会相当晚，甚至可能永远不会发生（例如，如果受害者正在等待来自控制台的输入，但用户没有输入任何内容）。

一个真正的操作系统将使用显式的空闲列表在常量时间内查找空闲的 `proc` 结构，而不是在 `allocproc` 中的线性时间搜索；xv6 使用线性扫描来简化。